# ch02. 변수
## 2.1 변수(variable)
### 변수란?
* 단 하나의 값을 저장할 수 있는 메모리 공간

### 변수의 선언과 초기화
```java
// [변수타입] [변수이름];
// ex
int age;
```
* 변수를 선언하면 메모리 빈 공간에 변수타입에 알맞은 크기의 저장공간이 확보되고, 변수이름으로 해당 공간을 사용할 수 있게 됨

변수의 초기화
* 변수를 사용하기 전 처음으로 값을 저장하는 것

### 변수 명명 규칙
* 대소문자 구분되고, 길이에 제한이 없음
* 예약어 사용하면 안됨
* 숫자로 시작하면 안됨
* 특수문자는 _, $만 사용 가능

권장 컨벤션
* 클래스 이름 시작은 대문자
* 여러 단어로 이루어진 이름은 단어의 첫글자를 대문자로
* 상수 이름은 모두 대문자, 여러 단어로 이루어진 경우 _로 구분

## 2.2 변수의 타입
기본형과 참조형
* 기본형(primitive type) : 실제 값을 저장
* 참조형(reference type) : 어떤 값이 저장되어 있는 주소를 저장

## 기본형(primitive type)
* 논리형
  * boolean : 1byte
* 문자형
  * char : 2byte
* 정수형
  * byte : 1byte
  * short : 2byte
  * int : 4byte
  * long : 8byte
* 실수형
  * float : 4byte
  * double : 8byte

## 상수와 리터럴(constant & literal)
* 상수(constant)
  * 한 번 값을 저장하면 다른 값으로 변경 불가.
  * 선언과 동시에 초기화 해야 함
  * 암묵적으로 모두 대문자로 하고, 여러 단어로 이루어진 경우 '_'로 구분
* 리터럴(literal)
  * 1, 'A' 이런 것 같은 값 그 자체
  * 기존에 알고 있던 상수의 다름 이름...

상수가 필요한 이유
* 리터럴에 의미있는 이름을 붙여서 코드 이해와 수정을 쉽게 함

리터럴 타입과 접미사
* 리터럴에 접미사를 붙여 타입을 구별
* ex
  * `10L`
  * `3.14f`
  * `1.6118d`

## 2.3 진법
### 10진법과 2진법
* 대부분의 컴퓨터는 2진체계로 설계되었음

### 비트와 바이트
워드(word) : CPU가 한 번에 처리할 수 있는 데이터 크기

## 2.4 기본형(primitive type)
### 논리형
* boolean

### 문자형
* char
  * 영문자 외에 특수문자를 저장하려면 특별한 방법 사용해야 함
  * `\t`

인코딩과 디코딩
* 문자를 숫자로 인코딩
* 숫자를 문자로 디코딩

### 정수형
정수형의 선택 기준
* byte, short 보다는 int 사용하자 -> byte, short가 메모리는 적용할 수 있는데 잘못된 결과 얻기가 쉬움
  * JVM 피연산자 스택이 피연산자를 4byte 단위로 저장해서 4byte보다 작은 자료형 계산할 때 4byte로 변환해서 연산이 수행됨 -> int 사용하는게 효과적
* 결론 : 정수형 변수를 선언 할 때는 int, int 범위를 넘어서 수를 다뤄야 할 때는 long을 사용하자

정수형의 오버플로우
* 해당 타입이 표현할 수 있는 값의 범위를 넘어가는걸 오버플로우라고 함...
* 최소값에서 1을 빼면 최대값이 되고, 최대값에 1을 더하면 최소값이 된다!

### 실수형
실수형의 범위와 정밀도
* float은 4byte, double은 8byte...
* 실수형도 정수형과 같이 저장 범위를 넘어서면 오버플로우가 발생하는지?
  * 실수형은 오버플로우 발생하면 값이 무한대(infinity)가 됨
  * 정수형에는 없는 언더플로우(underflow) : 실수형으로 표현 불가한 아주 작은 값... 양의 최소값보다 작은 값이 되는 경우 -> 0이 됨

<img width="323" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/00fc744b-41c0-4ad7-bf22-25019fdf916e">

* 정수형은 부호, 값
* 실수형은 부호(S), 지수(E), 기수(M)
  * 2의 제곱을 곱한 형태로 저장하기 때문에 큰 범위 값을 저장하는게 가능
* 실수형의 정밀도
  * 정수형과 다르게 실수형은 오차 발생이 가능
  * float은 정밀도가 7 -> 7자리의 10진수를 오차없이 젖아할 수 있다. 7자리 이상 정말도가 필요하면 double형으로 저장해야 함
  * float이 아닌 double 을 선택하는 기준 : 높은 정밀도
  * double이 아닌 float을 선택하는 기준 : 빠른 연산 속도

실수형 저장 형식
* `M * 2^E` 부동소수점수(floating-point)
* S : 부호(Sign bit) 0이면 양수, 1이면 음수
* E : 지수(Exponent) 부호 있는 정수...
* M : 가수(Mantissa) 실제 값을 저장하는 부분. 10진수로 7자리(float), 15자리(double) 정밀도로 저장

부동소수점 오차
* 실수를 저장할 때는 오차 발생 가능...
* 10진수가 아닌 2진수로 저장하기 때문에 유한소수여도 2진수로 변환하면 무한소수가 되는 경우가 있음
* 정규화된 2진 실수는 항상 1.으로 시작하기 때문에 2진수가 가수로 저장되고 그 이후는 잘려나감

## 2.5 형변환
### 형변환(casting) 이란?
* 변수 또는 상수의 타입을 다른 타입으로 변화하는 것

### 형변환 방법
* 변수, 리터럴 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기
```java
// (type) 피연산자
// ex)
double d = 1.2;
int score = (int)d;
```
* primitive type에서 boolean을 제회한 나머지 타입들은 서로 형변환이 가능함.
* 기본형과 참조형간의 형변환은 불가능

### 정수형간의 형변환
* 큰타입에서 작은타입으로 변환 시 크기의 차이만큼 잘려나감 -> 경우에 따라 값손실 가능...
* 작은타입에서 큰타입으로의 형변환은 값손실 X

### 실수형간의 형변환
* float타입 범위를 넘는 값을 float으로 형변환 시 무한대 또는 +-0을 결과로 얻음

### 정수형과 실수형간의 형변환
정수형 -> 실수형
* 정수를 2진수로 변환하고 정규화를 거쳐 실수 저장 형식으로 저장됨...
* 10진수로 8자리 이상 값을 실수형으로 변환할 때는 double로 변환해야 오차가 발생하지 않음

실수형 -> 정수형
* 실수형의 소수점 이하 값이 버려짐

### 자동형변환
컴파일러가 생략된 형변환을 자동적으로 추가하는 경우
```java
float f = 1234; // float f = (float)1234;
byte b = 1000; // 에러!!! byte 범위를 넘었음
char ch = (char)1000; // 명시적 형변환 -> 에러 발생 X
```

자동 형변환 규칙
* 기존 값을 최대한 보존할 수 있는 타입으로 자동형변환 함.
* boolean을 제외한 나머지 7개의 기본형은 서로 형변환 가능
* 기본형과 참조형은 서로 형변환 불가능
* 서로 다른 타입 변수간의 연산은 형변환 하는 것이 원칙이지만 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략 가능
