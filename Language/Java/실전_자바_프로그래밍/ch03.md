# ch03. 입출금 내역 분석기 확장판
## 3.1 도전 과제
* 여러 기능을 지원하는 새 버전의 입출금 내역기

## 3.2 목표
* 다양한 종류의 입출금 내역 검색
* 여러 포맷 지원
* 텍스트, HTML 등 형식으로 리포트를 내보내기
* 개방폐쇄원칙(OCP, Open/Closed Principle)
* 언제 인터페이스 사용해야 좋을지 가이드라인
* 높은 결합도 피할 수 있는 기법
* 언제 API에 예외를 포함하거나 포함하지 않는... 예외 처리 기법
* 그레이들을 이용해 시스템적 빌드

## 3.3 요구사항
1. 특정 입출금 내역 검색 (ex: 주어진 날짜, 특정 범주의 입출금 내역 얻기
2. 검색 결과 요약 통계를 텍스트, HTML 등 다양항 형식으로 만들기

## 3.4 개방/폐쇄 원칙
특정 금액 이상의 모든 입출금 내역 검색하는 메서드 만들고자 할 때...
* 메서드 만드려고 클래스를 추가해도 좋은 점이 없음... -> 클래스 추가하면서 여러 이름 생기면 동작간 관계를 이해하기 어려워지고 프로젝트가 복잡해짐
* 기존 클래스 안에 메서드를 정의하면 관련 메서드 쉽게 찾을 수 있음 -> 메서드 위치 정하기

특정 조건 만족하는 메서드 작성할 때...
* 거래 내역 속성 조합할수록 코드 복잡해짐
* 반복 로직과 비즈니스 로직 결합되어 분리 어려워짐
* 코드 반복

=> 이 경우 OCP 사용하여 해결
* 코드를 직접 바꾸지 않고 메서드/클래스의 동작을 변경 가능
* 비즈니스 로직을 담당하는 부분을 인터페이스로 만들어 해결

OCP를 사용하는 이유
* 기존 코드를 바꾸지 않아 기존 코드가 잘못될 가능성이 적어짐(사이드 이펙트 최소화)
* 코드 중복을 막아 기존 코드 재사용성 높아짐
* 결합도가 낮아져 유지보수성이 높아짐
  * 결합도가 낮다 : 다른 코드와 관련성이 적다... 한 클래스가 변경되면 다른 클래스를 변경해야 하고, 한 클래스를 이해하기 위해서는 다른 클래스를 이해해야 하고 이런 특성

## 3.5 인터페이스 문제
갓 인터페이스 (한 인터페이스 안에 모든 기능을 추가하는것)를 만드는 일은 피해야 한다~


갓 인터페이스
* 인터페이스가 복잡해짐
* 갓 클래스아 비슷한 인터페이스가 만들어짐
* 두가지 형식의 결합 발생
  * 자바 인터페이스는 모든 구현이 지켜야할 규칙 명시. 구현 클래스는 인터페이스의 모든 구현코드 제공해야 함... 인터페이스 바뀌면 모든 구현 코드가 바뀐 내용 지원하도록 갱신 -> 더 많은 연산 추가할수록 더 자주 코드가 변경되고, 문제가 자주 발생
  * 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생기면 도메인 객체 세부 내용 바뀌었을 때 인터페이스도 바뀌어야 하고 코드도 바뀌어야함
* 작은 인터페이스 구현 권장하는 이유 : 도메인 객체 다양한 내부 연산으로 디펜던시 최소화


안티응집도 문제(anti-cohesion)
* 지나치게 세밀한 응집도의 인터페이스..
* 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성 높아짐...

## 3.6 명시적 API vs 암묵적 API
일반적인 메서드를 쉽게 정의할 수 있는 상황에서 구체적으로 메서드를 정의해야 하는지, 쉽게 정의해야 하는지 의문...
* ex) `findTransactions()` vs `findTransactionsGreaterThanEqual()`
* 명시적 API
  * 자체적으로 어떤 동작 수행하는지 잘 설명되어 있고 사용 쉬움. 가독성을 높이며 쉽게 이해.... 
  * 특정 상황에 국항되어서 각 상황에 맞는 새로운 메서드를 많이 만들어야 함
* 암묵적 API
  * 처음 사용이 어렵고 문서화를 잘 해놓아야 함
  * 필요한 모든 상황에 해당 API를 사용하여 단순하게 처리 가능
* 정답은 없음....

## 3.7 다양항 형식으로 내보내기
새로운 도메인 객체를 선언하여 다양한 형식으로 내보낼 수 있음

인터페이스를 적절하게 정의하는 것이 중요

```java
public interface Exporter {
    void export(double a);
}
```
* 위 인터페이스가 나쁜 이유
  * void 반환 형식은 아무 도움 안됨... 기능 파악 어려움... 인터페이스로 부터 얻을 수 있는 정보가 없음
  * 출력이 없어서 테스트도 어려움

## 3.8 예외처리
고전적인 C프로그래밍에서는 if로 조건 분리해서 오류 코드 반환..
* 전역으로 공유된 가변 상태에 의해 최근에 발생한 오류 검색해야함
* 코드외 오류처리가 분리되어 이해가 어려움 -> 코드 예외 분리가 되지 않아 유지보수가 어려움

자바는 예외를 일급 언어 기능으로 추가하고 아래외 같은 장점 제공
* 문서화 : 메서드 시그니처 자체에 예외 지원
* 형식 안정성 : 개발자가 예외 흐름 처리하고 있는지를 시스템이 파악
* 관심사 분리 : 비즈니스 로직과 예외 회복이 try/catch로 분리됨
* 다만 복잡성 증가라는 단점이 생김...

자바가 지원하는 예외
* 확인된 예외 : 회복해야 하는 예외. 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 하거나 try/catch로 선언해야 함
* 미확인 예외 : 프로그램을 실행하면서 언제든 발생할 수 잇는 종류의 예외... 메서드 시그니처에 명시적으로 오류를 서넌하지 않음녀 호출자도 처리해야 할 필요가 없음
* 설명으로 이해가 안되서 찾아봄 https://codevang.tistory.com/140
  * 확인된 예외 = Exception, 잘못된 코드가 아니라 잘못된 상황에서 발생하는 예외. 개발자가 예외인거 알고 처리함~
  * 미확인 예외 = Error, 런타임 시 잘못 구현된 코드로 발생하는 예외. 개발자한테 허락되지 않은.. 그냥 에러 발생해버림