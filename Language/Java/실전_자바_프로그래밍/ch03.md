# ch03. 입출금 내역 분석기 확장판
## 3.1 도전 과제
* 여러 기능을 지원하는 새 버전의 입출금 내역기

## 3.2 목표
* 다양한 종류의 입출금 내역 검색
* 여러 포맷 지원
* 텍스트, HTML 등 형식으로 리포트를 내보내기
* 개방폐쇄원칙(OCP, Open/Closed Principle)
* 언제 인터페이스 사용해야 좋을지 가이드라인
* 높은 결합도 피할 수 있는 기법
* 언제 API에 예외를 포함하거나 포함하지 않는... 예외 처리 기법
* 그레이들을 이용해 시스템적 빌드

## 3.3 요구사항
1. 특정 입출금 내역 검색 (ex: 주어진 날짜, 특정 범주의 입출금 내역 얻기
2. 검색 결과 요약 통계를 텍스트, HTML 등 다양항 형식으로 만들기

## 3.4 개방/폐쇄 원칙
특정 금액 이상의 모든 입출금 내역 검색하는 메서드 만들고자 할 때...
* 메서드 만드려고 클래스를 추가해도 좋은 점이 없음... -> 클래스 추가하면서 여러 이름 생기면 동작간 관계를 이해하기 어려워지고 프로젝트가 복잡해짐
* 기존 클래스 안에 메서드를 정의하면 관련 메서드 쉽게 찾을 수 있음 -> 메서드 위치 정하기

특정 조건 만족하는 메서드 작성할 때...
* 거래 내역 속성 조합할수록 코드 복잡해짐
* 반복 로직과 비즈니스 로직 결합되어 분리 어려워짐
* 코드 반복

=> 이 경우 OCP 사용하여 해결
* 코드를 직접 바꾸지 않고 메서드/클래스의 동작을 변경 가능
* 비즈니스 로직을 담당하는 부분을 인터페이스로 만들어 해결

OCP를 사용하는 이유
* 기존 코드를 바꾸지 않아 기존 코드가 잘못될 가능성이 적어짐(사이드 이펙트 최소화)
* 코드 중복을 막아 기존 코드 재사용성 높아짐
* 결합도가 낮아져 유지보수성이 높아짐
  * 결합도가 낮다 : 다른 코드와 관련성이 적다... 한 클래스가 변경되면 다른 클래스를 변경해야 하고, 한 클래스를 이해하기 위해서는 다른 클래스를 이해해야 하고 이런 특성

## 3.5 인터페이스 문제
갓 인터페이스 (한 인터페이스 안에 모든 기능을 추가하는것)를 만드는 일은 피해야 한다~


갓 인터페이스
* 인터페이스가 복잡해짐
* 갓 클래스아 비슷한 인터페이스가 만들어짐
* 두가지 형식의 결합 발생
  * 자바 인터페이스는 모든 구현이 지켜야할 규칙 명시. 구현 클래스는 인터페이스의 모든 구현코드 제공해야 함... 인터페이스 바뀌면 모든 구현 코드가 바뀐 내용 지원하도록 갱신 -> 더 많은 연산 추가할수록 더 자주 코드가 변경되고, 문제가 자주 발생
  * 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생기면 도메인 객체 세부 내용 바뀌었을 때 인터페이스도 바뀌어야 하고 코드도 바뀌어야함
* 작은 인터페이스 구현 권장하는 이유 : 도메인 객체 다양한 내부 연산으로 디펜던시 최소화


안티응집도 문제(anti-cohesion)
* 지나치게 세밀한 응집도의 인터페이스..
* 자주 사용하는 기능을 쉽게 찾을 수 있어야 유지보수성 높아짐...

## 3.6 명시적 API vs 암묵적 API
일반적인 메서드를 쉽게 정의할 수 있는 상황에서 구체적으로 메서드를 정의해야 하는지, 쉽게 정의해야 하는지 의문...
* ex) `findTransactions()` vs `findTransactionsGreaterThanEqual()`
* 명시적 API
  * 자체적으로 어떤 동작 수행하는지 잘 설명되어 있고 사용 쉬움. 가독성을 높이며 쉽게 이해.... 
  * 특정 상황에 국항되어서 각 상황에 맞는 새로운 메서드를 많이 만들어야 함
* 암묵적 API
  * 처음 사용이 어렵고 문서화를 잘 해놓아야 함
  * 필요한 모든 상황에 해당 API를 사용하여 단순하게 처리 가능
* 정답은 없음....

## 3.7 다양항 형식으로 내보내기
새로운 도메인 객체를 선언하여 다양한 형식으로 내보낼 수 있음

인터페이스를 적절하게 정의하는 것이 중요

```java
public interface Exporter {
    void export(double a);
}
```
* 위 인터페이스가 나쁜 이유
  * void 반환 형식은 아무 도움 안됨... 기능 파악 어려움... 인터페이스로 부터 얻을 수 있는 정보가 없음
  * 출력이 없어서 테스트도 어려움

## 3.8 예외처리
고전적인 C프로그래밍에서는 if로 조건 분리해서 오류 코드 반환..
* 전역으로 공유된 가변 상태에 의해 최근에 발생한 오류 검색해야함
* 코드외 오류처리가 분리되어 이해가 어려움 -> 코드 예외 분리가 되지 않아 유지보수가 어려움

자바는 예외를 일급 언어 기능으로 추가하고 아래외 같은 장점 제공
* 문서화 : 메서드 시그니처 자체에 예외 지원
* 형식 안정성 : 개발자가 예외 흐름 처리하고 있는지를 시스템이 파악
* 관심사 분리 : 비즈니스 로직과 예외 회복이 try/catch로 분리됨
* 다만 복잡성 증가라는 단점이 생김...

자바가 지원하는 예외
* 확인된 예외 : 회복해야 하는 예외. 메서드가 던질 수 있는 확인된 예외 목록을 선언해야 하거나 try/catch로 선언해야 함
* 미확인 예외 : 프로그램을 실행하면서 언제든 발생할 수 잇는 종류의 예외... 메서드 시그니처에 명시적으로 오류를 서넌하지 않음녀 호출자도 처리해야 할 필요가 없음
* 설명으로 이해가 안되서 찾아봄 https://codevang.tistory.com/140
  * 확인된 예외 = Exception, 잘못된 코드가 아니라 잘못된 상황에서 발생하는 예외. 개발자가 예외인거 알고 처리함~
  * 미확인 예외 = Error, 런타임 시 잘못 구현된 코드로 발생하는 예외. 개발자한테 허락되지 않은.. 그냥 에러 발생해버림

예외 사용 가이드라인
* 예외를 무시하지 않음
  * 문제 근본을 알 수 없다고 예외를 무시하지 말자... 예외 처리할 수 없는 방법이 없으면 대신 미확인 예외를 던짐... -> 이렇게 하면 런타임에서 어떤 문제 발생하는지 파악 후 필요 작업 시작 가능
* 일반적인 예외는 잡지 않음
  * 구체적으로 예외를 잡으면 가독성이 높아지고 세밀하게 처리 가능
* 예외 문서화
  * API 수준에서 미확인 예외를 포함한 예외를 문서화 하므로 API 사용자에게 해결 실마리를 준다...
* 특정 문서에 종속된 예외를 주의할 것
* 예외 vs 제어 흐름
  * 예외로 흐름 제어 하지 않기... 예외처리 너무 남용하지 않기..... 가독성도 떨어질 뿐더러, 예외는 오류랑 예외 시나리오를 처리하는 기능이지 흐름제어 하는게 아님
  * 예외를 정말 전져야 하는 상황에서만 예외 던지기

예외 대안 기능
* null 사용
  * 예외 던지지 않고 null 반환해버리는 방법 => 절대 사용XXXXXXXXXXXXXX
  * 사용자에게 아무런 정보도 제공하지 않음.... + 결과가 항상 Null인지 체크해야함 -> 안하면 NullPointException
* null 객체 패턴(오브젝트 패턴)
  * 객체가 존재하지 않으면 null 레퍼런스 반환하는 대신 필요 인터페이스 구현 객체를 반환
  * NullPointException과 긴 null 확인코드를 피할 수 있다는 점이 장점...
  * 데이터에 문제가 있어도 빈 객체로 문제를 무시할 수 있기 때문에 문제 해결이 더 어려워짐
* Optional<T>
  * 자바8에서는 값이 없는 상태 표현하는 내장데이터 형식 Optional 선보임...
* Try<T>
  * 성공/실패 할 수 있는 연산

## 3.9 빌드 도구 사용
사용이유
* 으용 프로그램 실행하려면 `코드구현 -> 컴파일` 과정을 거쳐야 함...
* war, jar 같은 특정 형식으로 패키징 하고 디펜던시 관리 등등.... 문제 발생
* 스크립트를 만들어 모든 명령어를 자동화 하면 반복 실행 안해도 되는 장점!
* 테스트, 배포 등 과정을 자동화 할 수 있음...
* 빌드 도구는 프로그램 빌드, 테스트, 배포 등 생명주기 자동화 가능

빌드도구 장점
* 프로젝트에 적용되는 공통 구조를 제공하여 동료 개발자가 편하게 받아들임
* 응용프로그램 빌드-실행하는 반복적, 표준적 작업 설정
* 저수전 설정과 초기화에 들이는 시간 절약해서 개발 집중
* 잘못된 설정, 빌드 생략으로 발생하는 오류 줄임
* 공동 빌드 작업을 재사용해 다시 구형할 필요 없으므로 시간 절약

메이븐 
* xml 기반
* 가장 널리 사용됨

그레이들
* 메이븐은 가독성이 떨어짐... 메이븐 명령 저장하는것 쉽지 않고 xml 파일 유지보수 어려움
* Groovy, 코틀린을 이용해 친근한 도메인 특화 언어(DSL, Domain-Specific-Language) 적용
* 캐시, 점진적 컴파일 등 빌드 시간 단축 기능 지원


### 그냥 드는 생각
* 파이썬에서 매번 try-catch로 흐름제어 했는데 잘못..된거겠지...
