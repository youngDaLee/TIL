# ch05. 비즈니스 규칙 엔진
* 협업을 위한 비즈니스 규칙 엔진을 직접 구현

## 5.2 목표
* TDD
* mocking
* switch
* builder

## 5.3 요구사항
* 프로그래머가 아니어도 자신의 워크플로에 비즈니스 로직을 추가하거나 바꿀 수 잇어야 함
* 맞춤 언어로 한 개 이상의 비즈니스 규칙을 실행
    * 팩트 : 규칙이 확인 할 수 있는 정보
    * 액션 : 수행하려는 동작
    * 조건 : 액션을 언제 발생시킬지
    * 규칙 : 실행하려는 비즈니스 규칙을 지정.

## 5.4 TDD
TDD 사용 이유
* 테스트를 따로 구현하므로 테스트에 대응하는 요구사항을 한 개씩 구현할 때 마다 필요한 요구사항에 집중하고 개선
* 코드를 올바르게 조직 가능.
  * 테스트를 구현하며녀서 코드에 어떤 공개 인터페이스를 만들어야 하는지 검토
* TDD 주기에 따라 요구사항 구현을 반복하면서 종합적인 테스트 스위트를 완성 가능 -> 요구사항 만족시켰다는 사실을 확신 가능. 버그 발생 범위 축소
* 테스트를 통과하기 위한 코드를 구현하기 때문에 필요하지 않은 테스트 구현하는 일(오버 엔지니어링) 줄일 수 있음

TDD 주기
1. 실패하는 테스트 구현
2. 모든 테스트 실행
3. 기능 동작하도록 코드 구현
4. 모든 테스트 실행

+) 리팩터링까지 추가됨

## 5.5 모킹
* run() 이 실행되었을 때 이를 확인하는 기법
* 비즈니스 규칙에 액션을 추가할 때 마다 run() 실행되었는지 확인....


모키토(mockito) : 자바 모킹 라이브러리
* mock 생성
* 메서드 호출 확인

## 5.6 조건 추가
* 익명 클래스로 액션을 추가하거나 람다로 액션을 추가할 시 
  * 액션 테스트... 기능 코드가 독립적이지를 낳음
  * customer 객체가 그룹화 되지 않아 여러 곳에 공유된 외부상태 이기 때문에 엉킴
  * 요구사항을 새 클래스로 분리

지역변수 형식 추론
* 형식 추론(type inference) : 컴파일러가 정적 형식을 자동으로 추론해 결정하는 기능... 사용자가 명시적으로 형식을 지정 할 필요가 없음
  * 다이아몬드 연산자 `new HashMap<>()`
  * 지역변수 `var`
* 코드 구현 시간을 단축하지만, 읽는데 더 많은 시간을 소비함
* 가독성에 문제가 없다면 var를 사용하고 아니면 사용하지 말

switch문
* 분기처리
* 실수로 break 빼먹으면 폴스루(fall-through) 모드로 실행됨... 다음 블록 의도치않게 실행되면서 버그 발생
  * break문 없이 `->` 문법으로 대체 가능
* 가독성 좋아짐
* 모든 가능성 확인하는 소모검사도 이루어

인터페이스 분리 원칙(ISP)
* 비즈니스 규칙 엔진 사용자가 사용할 수 있는 액션, 조건을 검사할 수 있더록 인스펙터 도구를 개발해 제공.... -> 현 Action은 수행과 조건이 분리되어 있지 ㅇ낳아 구현 불가능
* evaluate 메서드 포함하도록 새 인터페이스 ConditionalAction 생성

인터페이스 분리 원칙
* 어떤 클래스도 사용하지 않는 메서드에 의존성을 갖지 않아야 한다 -> 불필요한 결합을 만들기 때문
* SRP(단일책임원리) : 클래스가 하나의 의무만 갖게 하고 클래스를 바꾸는 이유도 한 가지여야 한다
* ISP : 인터페이스가 커지면 인터페이스 사용자는 사용하지 않는 기능을 갖게 되며, 이는 불필요한 결합도를 가진다
* ISP에 따라 현재의 개념을 독자적으로 쪼개야 한다..

## 5.7 플루언트 API 설계
플루언트 API
* 특정 문제를 더 직관적으로 해결할 수 있도록 특정 도메인에 맞춰진 API
* 메서드 체이닝을 이용하면 더 복잡한 연산도 지정 가능...
* ex) 스트림API : 문제를 실제로 해결하는데 필요한 언어를 사용하는 것 처럼 데이터 처리 쿼리를 지정

도메인 모델링
* given
* when
* then



