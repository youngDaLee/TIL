# 문서 관리 시스템
## 4.1 과제

## 4.2 목표
* 리스코프 치환 원칙
* 상속보다 조합

## 4.3 요구사항
* 문서를관리하고 필요한 정보를 빨리 찾을 수 있는 시스템
* 기존 환자 정보 파일을 읽어 색인 추가하고 검색할 수 있는 형태 정보로 변환
    * 리포트 : 환자의 수술과 관련된 상담 내용을 기록한 본문
    * 우편물 : 특정 주소로 발송되는 텍스트 문서
    * 이미지 : 치아와 잇몸 엑스레이 사진을 저장. 용량이 크다
    * 각각의 문서는 파일 경로, 어떤 환자 기록물인지도 포함해야 함.
    * 다양한 종류의 문서에서 측정 정보를 포함하는 문서를 찾아 검색...
    * 추후 다른 문서 추가

## 4.4 설계 작업
TDD -> 프로그램을 시작하는 아주 좋으 ㄴ방법... -> 일단 5장해서 하고 4장은 스킵

* DocumentManagementSystem
  * `void importFile(String path)` : 임포트 하려는 파일 경로를 받는다.
  * `List<Document> contents()` : 문서 관리 시스템에 저장된 모든 문서 목록을 반환한다.


### 임포터
* switch로 하면 해결 가능하지만 확장성이 부족 -> 추가 될 때 마다 항목 추가해야 함....
* 메인 클래스 깔끔하게 유지하기 위해 임포트 하는 클래스를 분리 -> 다양한 종류 임포트 지원하기 위해 Import 인터페이스 정의
  * 강한 형식(strong type)의 원칙 : 파일 경로를 String으로 처리하면 오류 발생 범위가 넓어짐 -> File로 정의해서 오류 발생 범위를 줄인다

### Document 클래스
* 각 문서는 검색할 수 있는 다양한 속성을 포함함... 
* Map<String, String>으로 정의하지 않는 이유 : 응용프로그램 유지보수성, 가독성 고려
* 훌륭한 소프트웨어 개발팀은 유비쿼터스 언어(ubiquitous langugae)로 소프트웨어를 작성한다.
  * 소프트웨어의 다양한 기능을 어떤 공통 언어로 약속하고, 사용한 어휘를 코드로 매핑하면 코드 어떤 부분을 바꿔야 하는지 알 수 있음 => 발견성(discoverability)
  * 유비쿼터스 언어 : DDD에서 처음 나온 용어. 개발자와 사용자가 모두 사용할 수 있도록 설계, 공유된 공통 언어
* 이 책에서는 클래스로 모델을 만들어 강한 형식의 원칙을 따르도록 권장함...
  * 강한 형식 이용하면 데이터 사용 방법 규제 가능
* Document 클래스를 생성한 다음에는 클래스 속성을 바꿀 수 없음. 불변클래스(immutable)
  * Document 속성 오류 발생하면 Document 생성한 Import 구현 확인하면 되므로 오류 발생 원인 좁힐 수 있음
* 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한해서 발견성을 개선하고 버그 발생 범위를 줄일 수 있음...


문자화 형식(stringly typed)
* 강한 형식의 반대. 모두 문자(String)화 해서 느슨하게 관리...

KISS : 단순할 수록 좋다. 최대한 단순하게 처리해라...

### 임포터 구현과 등록

## 4.5 리스코프 치환 원칙(LSP, Liskov substitution principle)
* 형식(type) : 클래스, 인터페이스
* 하위형식(subtype) : 두 형식이 부모와 자식 관계를 이루었음

LSP
* q(x) 는 T형식의 x객체를 증명할 수 있는 공식
* S형식의 객체 y, S가 T의 하위 형식
* q(y) 는 참

### 하위 형식에서 선행 조건을 더할 수 없음
* 선행조건은 어떤 코드가 동작하는 조건을 결정....
* LSP는 부모가 지정한 것 보다 더 많은 선행조건을 요구할 수 없음을 의미
  * 부모가 문서 크기를 제한하지 않았다면 문서 크기가 100KB보다 작아야 한다고 요구할 수 없다....

### 하위 형식에서 후행 조건을 약화시킬 수 없음
후행 조건은 어떤 코드를 실행한 다음에 만족해야 하는 규칙... 유효한 파일에 importFile()을 실행했다면 contents()가 반드시 문서 목록에 포함되어야 함

### 슈퍼 형식의 불변자는 하위 형식에서 보존됨
불변자 : 변하지 않는 어떤 것... 상속 관계에서 부모-자식 클래스가 있을 때 부모 클래스의 불변자는 자식 클래스에서도 유지되어야 한다

### 히스토리 규칙
자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않음. Document는 바꿀 수 없는 불변클래스!!    
Document클래스를 인스턴스화 한 다음에는 어떤 속성도 추가, 변경, 삭제 될 수 없음... 모든 부모 클래스 사용자는 Document 클래스의 메서드를 호출했을 때 어떤 일이 일어날 수 있음을 인지하고 있기 때문
* 자식이 불변이 아니면 호출자의 예상을 엎을 것이다~...

## 4.6 대안
### 임포터를 클래스로 만들기
* 임포터 클래스 계층을 만들어 인터페이스 대신에 상위에 Importer 클래스를 만드는 방법...
* 인터페이스는 여러개를 한 번에 구현할 수 있지만 클래스는 일반 인스턴스 필드와 메서드를 가짐...
  * 상속 기반의 클래스를 피해야 한다 : 쉽게 망가질 수 잇음
  * is a 관계를 모델링 해야 하는 상황이면 상속이 적절... 예제는 그런게 아니라 인터페이스가 적절

### 영역, 캡슐화 선택하기
* 같은 패키지 안의 클래스만 패키지 영역의 클래스를 보거나 접근 가능... 
* 실제 개발에서는 public 영역 많이 사용....

## 4.7 기존 코드 확장과 재사용
문자열 행에 접미어를 찾는 메서드를 세 개의 임포트에 모두 구현해야 한다 했을 때 세 가지 방법 중 하나 선택 가능
* 유틸리티 클래스 사용
* 상속 사용
* 도메인 클래스 사용

### 유틸리티 클래스 사용
* 가장 간단
* ImportUtil 클래스 만들어서 공유해야 하는 기능을 유틸 클래스에 공유
* 유틸리티 클래스는 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결됨... -> 시간 지날수록 여러 의무 담당하는 거대 클래스로 만들어짐...

### 상속 사용
* 각각의 임포터가 TextImporter 클래스를 상속받는 방법
* TextImporter에 모든 공통 기능을 구현하고 서브클래스에서 재사용하는 방법
* 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다... 상속으로 코드를 재사용 하는 건 좋은 방법이 아니다

### 도메인 클래스 사용
도메인 클래스로 텍스트 파일 모델링
* 기본 개념을 모델링 하고, 기본 개념이 제공하는 메서드를 호출해서 다양한 임포터를 만듬
* 기본 개념 : 텍스트 파일 내용 처리해야 하니까 TextFile 클래스를 만든다 ~ 클래스 이름 단순명료하게!. 어디 사용하는지 알 수 있게..


## 4.8 테스트 위생
자동화된 테스트는 퇴행이 발생하는 범위를 줄이고 어떤 동작이 문제 일으키는지 확인 가능함... 테스트 유지보수 문제를 해결하기 위해 테스트 위생을 지킬것~

### 테스트 이름 짓기
* 도메인 용어 사용 : 응용 프로그램에서 문제를 지칭하는 용어로 테스트 이름을 사용함
* 자연어 사용 : 모든 테스트는 일반 문장처럼 쉽게 읽을 수 있어야 함
* 서술적 : 나중에 쉽게 읽을 수 있도록 서술적인 이름을 짓기

### 구현이 아닌 동작
* 공개 동작만 테스트...
* 내부 상태나 설계는 고려하지 않고 공개 API 메서드만 이용해 테스트를 수행해야 함...

### 중복 배제
* 테스트 코드에서도 중복 코드를 배제해야 함

### 좋은 진단
* 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 함
* 진단 : 테스트가 실패했을 때 출력하는 메세지와 정보....

### 오류 상황 테스트

### 상수
