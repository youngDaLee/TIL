# ch04. 상속과 리플렉션
## 질문
- 공변반환타입(covariant return type) 이 뭔가요
- 동적메서드 조회에 대해 설명하세요
- abstract와 interface의 차이점이 무엇인지, 오버라이딩이 무엇인지 설명하세요
  - https://brunch.co.kr/@kd4/6
  - 추상클래스는 "확장"이 주 목적이고, 인터페이스는 "구현, 통일성"이 목적임.
  - 하위클래스가 여러 상위 추상클래스를 구현하는 다중상속은 불가능
  - 하위 클래스가 여러 인터페이스 구현은 가능
  - => 그런데 인터페이스를 쓰는 이유가 다중상속 때문은 아님. 그보다는 주 목적인 확장과 다형성이 이유.
  - 간혹 추상클래스에서 추상클래스에서 미리 구현된 메서드를 사용할 수 있다는 것으로 인터페이스와 차이를 설명하는 글이 있는데, 인터페이스에서도 default 메서드로 미리 메서드를 구현할 수 있다... 따라서 확장의 의미를 설명하는데 이건 잘못된 예시
- protected는 언제 사용할까요

## 정리
- 상속 : 기존 클래스를 기반으로 새로운 클래스를 생성하는 과정
- 필드(field) : 인스턴스 변수와 정적 변수를 총칭
- 멤버(member) : 클래스 내부의 중첩 클래스와 인터페이스를 총칭하는 말
- 리플렉션 : 실행중인 프로그램에서 클래스와 멤버 정보를 자세히 찾아내는 프로그래밍 기법

### 클래스 확장
- extends : 기존 클래스에서 파생된 새 클래스를 만든다
  - 기존클래스 = 슈퍼클래스 = 상위클래스
  - 새클래스 = 서브클래스 = 하위클래스
- 서브클래스에서 슈퍼클래스의 메서드를 수정하고싶을 때, 오버라이드해서 수정한다.
  - 오버라이드 할 때는 매개변수 타입이 정확하게 일치해야 한다.
  - 다른 매개변수 타입을 쓰고싶을땐 오버라이드 받지 말고 새로 정의하자...
  - 공변반환타입(covariant return type) : 메서드를 오버라이드 할 때 반환타입을 서브타입으로 바꾸는 것
```java
// 상위 클래스 Employee, 하위클래스 Manager
public Employee getSupervisor()
@Override public Manager getSupervisor()
```

- 서브클래스 생성자에서 슈퍼클래스 생성자를 호출할 땐 반드시 **첫번째 문장**으로 호출해야 함
```java
public Manager (String name, String salary) {
    super(name, salary);
    bonus = 0;
}
```
- 슈퍼클래스 할당 : 서브클래스 객체를 슈퍼클래스 타입 변수에 할당 가능. => 메서드를 호출할 때 가상머시는 객체 실제 클래스를 살펴보고 해당 클래스에 맞는 메서드 버전을 찾아 샐힝 => 동적 메서드 조회(dynamic method lookup)

final
- 메서드를 final로 선언하면 어떤 서브클래스도 해당 메서드를 오버라이드 할 수 없다.
- 서브 클래스의 특정 메서드를 절대 변경될 수 없게 할 때 사용함
  - 일부 프로그래머는 final을 효율이 좋다고 생각하는데, 자바 초창기는 그렇지만 지금은 아님.
- 클래스를 정의할 때 final 제어자를 사용하면 자신이 만든 클래스의 서브클래스를 만들지 못하게 할 수 있음

추상메서드, 추상클래스
- 구현이 없는 메서드, 클래스.
- 추상메서드와 추상클래스에는 abstract를 붙여야 함
- 추상클래스에는 비추상 메서드를 포함할 수 있음.
- 추상클래스 인스턴스는 생성할 수 없음 -> 변수에 구체적인 객체참조를 저장하면 추상클래스 타입으로 변수선언하는 것은 가능함

protected
- 메서드를 서브클래스 전용으로 제한하거나 서브클래스 메서드에서 슈퍼클래스 인스턴스에 접근할 때 사용.
- 내가 이해한 것 : 메서드나 변수를 상속받아 사용할 때, 해당 클래스(서브/슈퍼) 에서만 사용되는 변수/메서드를 만들 때 사용. 상속받아야만 해당 메서드/변수를 사용할 수 있도록 보호

익명 서브클래스
- 인터페이스를 구현하는 익명 클래스처럼, 슈퍼클래스를 확장하는 익명클래스를 만들 수 있음



Object: 보편적 슈퍼클래스
- 자바에서 모든 클래스는 직간접적으로 Object 클래스를 확장함. 클래스에 명시적인 슈퍼클래스가 없으면 암시적으로 Object를 확장함
- Object 클래스의 메서드
  - toString
  - equals : 두 객체 참조가 동일한지 판단
  - hashCode : 객체에서 파생한 정수값. equals와 호환되어야 함.
    - `x.equalse(y)` 면 `x.hashCode() == y.hashCode()`
  - 객체 복제
    - 얕은 복제 : 인스턴스 변수가 기본 타입이거나 불변 객체일때는 얕은 복제로 충분. 그렇지 않으면 원본과 복제본이 변경 가능한 상태를 공유함
    - 깊은 복제 : 복사본을 변경할 때 원본을 건드리지 않는 것 

열거


시행시간 타입 정보와 리소스

리플렉션

