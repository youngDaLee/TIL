# ch03. 자바와 객체지향
## 3.1 객체 지향은 인간 지향이다
구조적 프로그래밍의 핵심 "함수"
* Divide and Conquer. 분할정복. 명령어를 논리적 단위로 블록화해서 작성하자~
* 논리적인 단위 블록 = 함수

객체지향을 위한 큰그림
* 세상에 존재하는 모든 것은 object(사물)이다
* 각각의 object는 고유하다
* object(사물)는 property(속성)를 갖는다
* object(사물)는 method(행위)를 한다
* obeject(사물)를 분류(class) 해서 이해한다
  * ex: 이다영(object), 김연아(object)는 사람(class)이다. 각각의 object는 나이, 몸무게, 키 등의 속성(property)과 먹다, 울다 등의 행위(method)를 갖는다

## 3.2 객체 지향의 4대 특성 - 캡! 상추다
객체지향의 4대 특성 (캡상추다)
* 캡 - 캡슐화(Encapsulation) : 정보 은닉(information hiding)
* 상 - 상속(Inheritance) : 재사용
* 추 - 추상화(Abstraction) : 모델링
* 다 - 다형성(Polymorphism) : 사용 편의

## 3.3 클래스 vs 객체 = 붕어빵틀 vs 붕어빵???
흔한 비유인 붕어빵틀과 붕어빵은 틀린 비유임... 붕어빵틀은 굳이 따지면 **팩토리** 이다.
* 맞네...?

사람 - 이다영 의 관계개 클래스와 객체의 관계
* 사람은 몇 살인가? : 말이 안됨
* 이다영은 몇 살인가? : 25살. 객체임

즉 클래스와 객체의 관계는 분류와 사물의 관계 / 개념과 실체의 관계임

## 3.4 추상화: 모델링
> 추상의 사전적 의미 : 여러 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

추상화는 모델링이다
* 객체는 유일무이한 사물이고, 클래스는 같은 속성과 기능을 가진 객체를 총칭하는 개념이다.
* 개발자는 객체지향 설계를 할 때 클래스를 먼저 설계하게 된다.
* context = 애플리케이션 경계. 즉 어떤 어플리케이션인지~ 클래스 용도가 뭔지~ 이런거

> 추상화란 구체적인 것을 분해해서 관심영역(context)에 있는 특성만 가지고 재조합 하는 것 = 모델링

* OOP의 추상화는 모델링이다
* 클래스 설계에서 추상화가 사용된다
* 클래스 설계를 위해 context부터 정해야 한다(목적)
* 객체 지향에서 추상화의 결과는 클래스다

+) instance : 클래스를 이용해 객체(object)를 만들었다는 것을 강조할 때 쓰는 표현. 객체는 클래스의 인스턴스이다.

### 추상화와 T메모리
* 객체가 생성되어야만 속성 값을 저장하기 위한 메모리공간이 힙영역에 할당됨. 힙영역에 객체(object)가 저장됨
* 사용되지 않는 객체는 가비지 컬렉터에 의해 삭제됨

### 클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버
* 모든 객체가 같은 값을 가지고 있는 경우 모든 오브젝트 멤버에 property를 부여하지 않고, 클래스 멤버에 저장해 T메모리의 static 영역에 위치하도록 함. -> 메모리 절약~
* 구현하는 방법 = `static`
  * static은 메모리상 단 하나의 공간(static영역)에 존재.

클래스 설계
* 클래스 멤버 : static
  * 클래스 멤버 속성
  * 클래스 멤버 메서드
* 객체 멤버
  *  객체 멤버 속성
  * 객체 멤버 메서드

클래스 멤버는 static 키워드와 사용되고, T메모리 static영역에 존재하여 static(정적)멤버 라고도 함.
* 클래스 멤버 = static 멤버 = 정적 멤버 -> 스태틱 영역에 존재
* 객체 멤버 = 인스턴스 멤버 -> 힙 영역에 존재
* local 변수 = 지역변수 -> 스택 영역에 존재

실무에서는 유틸리티성 메서드를 정적 메서드로 구현하기도 ~ 

## 3.5 상속: 재사용 + 확장
상속보다는 재사용과 확장으로 이해하는게 뜻에 더 맞음~ 부모자식 보다는 상위/하위, 슈퍼/서브 로 표현하도록 하자!
> 객체지향에서의 상속은 확장, 세분화 슈퍼클래스-서브클래스(상위클래스-하위클래스) 의 개념이다.

상속 관계에서 반드시 만족하는 문장
* 하위 클래스는 상위 클래스다
  * 아버지는 할아버지다 -> 상속 아님ㅠ!
  * 포유류는 동물이다 -> 마즘
* 상속한다는 것은 상위 클래스의 특성을 상속한다는 의미..

상속이라 가능한 것
```java
public class Test{
    public static void main(String[] args) {
        동물 animal = new 동물();
        동물 mammalia = new 포유류();
        동물 bird = new 조류();
        동물 whale = new 고래();
        동물 bat = new 박쥐();
        
        List<동물> animals = new ArrayList();
        animals.add(new 동물());
        animals.add(new 포유류());
        animals.add(new 조류());
        animals.add(new 고래());
        animals.add(new 박쥐());
        for (동물 animal : animals) {
            animal.showMe();
        }
    }
}
```

### 다중상속과 자바
* 자바는 다중상속을 지원 안함
* 인어가 사람과 물고기 둘 다 상속하게 된다고 가정했을 때, 사람의 모든 특성을 갖지도 못했고 물고기의 모든특성을 갖지 못했기 때문에 문제 발생 -> 요런 비유~

### 상속과 인터페이스
상속은 is a kind of 관계. 하위클래스 is a kind of 상위클래스(펭귄 is a kind of 동물)

자바는 다중사옷ㄱ을 포기하고 인터페이스를 도입합.
* 인터페이스 : 구현클래스 is able to 인터페이스.
  * ex) 고래 is able to 헤엄
* 인터페이스는 "무엇을 할 수 있다"고 기능을 강제하게 됨.

* 상위클래스는 하위클래스에게 물려줄 특성이 많을수록 좋냐 적을수록 좋냐? : 많을수록 좋음
* 인터페이스는 구현을 강제할 메서드가 많을수록 좋냐 적을수록 좋냐? : 적을수록 좋음

=> 상위클래스 프로퍼티가 많을수록, 인터페이스 메서드가 적을수록 좋은 이유 : LSP(리스코프 치환 원칙), ISP(인터페이스 분할 원칙)

### 상속과 T메모리
* 하위 클래스 호출 시 상위 클래스의 인스턴스도 힙영역에 생성됨!!!

## 3.6 다형성: 사용편의성
객체지향에서의 다형성은 오버라이딩(overriding)과 오버로딩(overloading). 
* 오버라이팅 : 올라타다. 같은 메서드 이름, 같은 인자 목록으로 상위 클래스 메서드 재정의
* 오버로딩 : 적재하다. 같은 메서드 이름, 다른 인자 목록으로 다수 메서드 중복 정의

```java
public class Animal {
  public String name;

  public void showName() {
    System.out.println("안녕 나는 %s야", name);
  }
}

public class Penguin extends Animal {
  public String habitat;

  public String getHabitat() {
    return habitat;
  }

  // 오버라이딩 - 재정의 : 상위클래스와 같은 메서드, 같은 인자
  public void showName() {
    System.out.println("오버라이딩이야");
  }
  
  // 오버로딩 - 중복정의 : 상위클래스와 같은 메서드, 다른 인자
  public void showName(String newName) {
    System.out.println("사실 진짜 이름은 %s야", newName);
  }
}
```

### 다형성이 적용되지 않는 언어
* 같은 역할 하는 함수에 대해 다른 이름을 부여해야 함... => 다형성이 사용 편의성인 이유.
* 참조변수에서 하위클래스가 오버라이딩한 메서드를 자동으로 호출함으로서 깔끔한 코드 유지.

## 3.7 캡슐화: 정보 은닉
자바에서의 정보 은닉은 접근제어자인 private, default, protected, public.    
접근제어자가 객체 멤버(인스턴스 멤버)와 쓰일때와 정적 멤버(클래스 멤버)와 쓰일때를 비교

### 객체 멤버의 접근제어자
* 자신의 멤버가 아닌 다른 객체 멤버에 접근하는 경우 다른 객체 생성 후 접근.

* 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 참조 변수를 이용해 접근해야 함
* 정적 멤버는 `클래스명.정정멤버` 형식으로 접근을 권장

### 참조 변수 복사
* Call by Value
* Call by Reference

기억할 부분
* 기본 자료형 변수는 값을 값 자체로 판단함
* 참조 자료형 변수는 값을 주소, 즉 포인터로 판단함
* 기본 자료형 변수를 복사할 때 참조자료형 변수를 복사할 때 일어나는일은 같음. 즉 가지고 있는 값을 그대로 복사해서 넘겨줌

## 질문
- OOP 4대 원칙에 대해 설명하시오
- 캡슐화의 public, protected, default, private 이 각각 어느 경우에 접근 가능한지 에시를 들어 설명하시오
- call by value와 call by reference에 대해 설명하세요