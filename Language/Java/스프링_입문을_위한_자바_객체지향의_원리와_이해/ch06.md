# ch06. 스프링이 사랑한 디자인 패턴
스프링 프레임워크? = OOP 프레임워크
* 객체지향 설계 원칙을 극한까지 적용한 프레임워크.

## 6.1 어댑터 패턴(Adapter Patter)
* 변환기. 서로다른 두 인터페이스 사이에 통신이 가능하게 하는 것.
* 비슷한 일을 하는 메서드가, 서로 다른 메서드명을 가질 수 있음 => 어댑터 패턴을 통해 메서드 명을 정리하는 어댑터 클래스를 두고, 해당 클래스로 같은 메서드명을 사용하도록 설정 가능
* 호출당하는 쪽의 메서드를 호출하는 쪽에 ㅗ드에 대응하도록 중간에 변환기를 통해 호출하는 패턴

## 6.2 프록시 패턴(Proxy Pattern)
> 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

* proxy : 대리자, 대변인
* 인터페이스를 사용하여 서비스 객체가 들어갈 자리에 대리자 객체를 투입해서, 실제 서비스 객체를 통한 호출인지 proxy 객체를 통한 호출인지 모르게 하는 것
* 내가 이해한 목적 : 메서드는 해당 작업을 실행하는 역할만 하고, proxy가 해당 메서드에 대한 흐름 제어를 하는 것(실패 결과에 대한 처리 등)


프록시 패턴의 중요 포인트
* proxy는 실제 서비스와 같은 이름의 메서드를 구현한다. 이 때 인터페이스를 사용한다.
* proxy는 실제 서비스에 대한 참조 변수를 갖는다(합성)
* proxy는 실제 서비스와 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다
* proxy는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.


DIP와 OCP가 적용된 패턴이다!

## 6.3 데코레이터 패턴(Decorator Pattern)
> 메서드 호출의 반환값에 변화를 두기 위해 중간에 데코레이터(장식자)를 두는 패턴

* 원본에 장식을 더하는 패턴
    * 프록시 : 제어 흐름 변경/별도 로직 처리 => 클라이언트가 얻는 반환값은 특별한 경우가 아닌 이상 변경하지 않음
    * 데코레이터 : 클라이언트가 얻는 반환값을 변경함

데코레이터 중요 포인트
* 데코레이터는 실제 서비스와 같은 이름의 메서드를 구현한다. 이 때 인터페이스를 사용한다.
* 데코레이터는 실제 서비스에 대한 참조 변수를 갖는다(합성)
* 데코레이터는 실제 서비스와 같은 이름을 가진 메서드를 호출하고, 그 값에 **장식(데코레이터)**을 더해 클라이언트에게 돌려준다
* 데코레이터는 실제 서비스의 메서드 호출 전후에 별도에 로직을 수행할 수도 있다.

OCP와 DIP 적용된 패턴~~~

## 6.4 싱글턴 패턴(Singleton Pattern)

## 6.5 템플릿 메서드 패턴(Template Method Pattern)

## 6.6 팩터리 메서드 패턴(Factory Method Pattern)

## 6.7 전략 패턴(Strategy Pattern)

## 6.8 템플릿 콜백 페턴(Template Callback Patter - 견본/회신 패턴)

## 6.9 스프링이 사랑한 패턴들

## 질문 
* 처음부터 메서드 명을 통일해서 클래스를 작성하면 되는데, 왜 굳이 어댑터 패턴을 사용해서 클래스를 거쳐가야 하는 구조인지?