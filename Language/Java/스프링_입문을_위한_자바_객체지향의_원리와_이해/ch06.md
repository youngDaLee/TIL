# ch06. 스프링이 사랑한 디자인 패턴
스프링 프레임워크? = OOP 프레임워크
* 객체지향 설계 원칙을 극한까지 적용한 프레임워크.

## 6.1 어댑터 패턴(Adapter Patter)
* 변환기. 서로다른 두 인터페이스 사이에 통신이 가능하게 하는 것.
* 비슷한 일을 하는 메서드가, 서로 다른 메서드명을 가질 수 있음 => 어댑터 패턴을 통해 메서드 명을 정리하는 어댑터 클래스를 두고, 해당 클래스로 같은 메서드명을 사용하도록 설정 가능
* 호출당하는 쪽의 메서드를 호출하는 쪽에 ㅗ드에 대응하도록 중간에 변환기를 통해 호출하는 패턴

## 6.2 프록시 패턴(Proxy Pattern)
> 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴

* proxy : 대리자, 대변인
* 인터페이스를 사용하여 서비스 객체가 들어갈 자리에 대리자 객체를 투입해서, 실제 서비스 객체를 통한 호출인지 proxy 객체를 통한 호출인지 모르게 하는 것
* 내가 이해한 목적 : 메서드는 해당 작업을 실행하는 역할만 하고, proxy가 해당 메서드에 대한 흐름 제어를 하는 것(실패 결과에 대한 처리 등)


프록시 패턴의 중요 포인트
* proxy는 실제 서비스와 같은 이름의 메서드를 구현한다. 이 때 인터페이스를 사용한다.
* proxy는 실제 서비스에 대한 참조 변수를 갖는다(합성)
* proxy는 실제 서비스와 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다
* proxy는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.


DIP와 OCP가 적용된 패턴이다!

## 6.3 데코레이터 패턴(Decorator Pattern)
> 메서드 호출의 반환값에 변화를 두기 위해 중간에 데코레이터(장식자)를 두는 패턴

* 원본에 장식을 더하는 패턴
    * 프록시 : 제어 흐름 변경/별도 로직 처리 => 클라이언트가 얻는 반환값은 특별한 경우가 아닌 이상 변경하지 않음
    * 데코레이터 : 클라이언트가 얻는 반환값을 변경함

데코레이터 중요 포인트
* 데코레이터는 실제 서비스와 같은 이름의 메서드를 구현한다. 이 때 인터페이스를 사용한다.
* 데코레이터는 실제 서비스에 대한 참조 변수를 갖는다(합성)
* 데코레이터는 실제 서비스와 같은 이름을 가진 메서드를 호출하고, 그 값에 **장식(데코레이터)**을 더해 클라이언트에게 돌려준다
* 데코레이터는 실제 서비스의 메서드 호출 전후에 별도에 로직을 수행할 수도 있다.

OCP와 DIP 적용된 패턴~~~

## 6.4 싱글턴 패턴(Singleton Pattern)
인스턴스를 하나만 만들고 재사용함. -> 커넥션풀, 스레드풀, 디바이스 설정 객체 같은 경우는 인스턴스를 여러 개 만들면 불필요한 자원을 사용하게 됨
객체 생성(new)에 제약을 걸어야 하고, 만들어진 단일 객체를 리턴하는 메서드가 필요함
* new를 실행할 수 없도록 생성자에 private 접근제어자를 지정
* 유일한 단일 객체를 반환할 수 있는 정적메서드가 필요
* 유일한 단일 객체를 참조할 정적 참조 변수가 필요

싱글톤 특징
* private 생성자
* 단일 객체 참조 변수를 static으로 가짐
* 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적메서드를 가짐
* 단일 객체는 쓰기 가능한 속성을 갖지 않는게 정석

## 6.5 템플릿 메서드 패턴(Template Method Pattern)
> 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴

* 메서드가 하는 일에서 일부를 제외하고 거의 같은 일을 할 때..
* 추상클래스를 통해 강제 구현할 메서드(추상메서드), 오버라이딩 할 수 이쓴 훅메서드를 두는 패턴
* 의존관계 역전(DIP)을 활용함

## 6.6 팩터리 메서드 패턴(Factory Method Pattern)
> 오버라이드된 메서드가 객체를 반환하는 패턴

* 팩터리 메서드 : 객체를 생성 반환하는 메서드
* 하위클래스에서 팩터리 메서드를 오버라이딩해서 객체를 반환하게 하는거~

## 6.7 전략 패턴(Strategy Pattern)
> 클라이언트가 정략을 생성해 전략을실행할 컨텍스트에 주입하는 패턴

* strategy method를 가진 strategy 객체
* strategy 객체를 가진 컨텍스트(전략객체 사용자/소비자)
* strategy 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자. strategy객체 공급자)

군인과 군인이 사용할 무기가 있을 때... 보급 장교가 군인에게 무기 지급하면 군인은 지급된 무기로 전투 수행 => 무기=strategy/군인=컨텍스트/보급장교=공급자
* 전략(무기)를 다양하게 바꾸면서 컨텍스트를 실행할 수 있음...
* 상속을 이용하는 템플릿 메서드 패턴, DIP를 이용하는 전략 패턴 중 선택적용 할 수 있음

## 6.8 템플릿 콜백 페턴(Template Callback Patter - 견본/회신 패턴)

## 6.9 스프링이 사랑한 패턴들

## 질문 
* 처음부터 메서드 명을 통일해서 클래스를 작성하면 되는데, 왜 굳이 어댑터 패턴을 사용해서 클래스를 거쳐가야 하는 구조인지?
* getInstance 메서드를 가진 객체는 전부 싱글톤인가?