# ch05. 객체 지향 설계 5원칙 -SOLID
- 응집도는 높이고(High Cohesion), 결합도는 낮추라(Loose Coupling)
    - 결합도 : 클래스간 상호 의존 정도. 결합도가 낮으면 클래스간 의존성이 줄어들어 객체 재사용, 수정, 유지보수에 용이
    - 응집도 : 하나의 클래스 내부에 존재하는 요소간의 기능적 관련성. 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용성, 기능 수정, 유지보수가 용이

## 5.1 SRP - 단일 책임 원칙
> 어떤 클래스를 변경하는 이유는 오직 하나뿐이어야 한다

클래스를 역할과 책임에 따라 분리하여 하나의 역할과 책임만 갖게 하는 것.
* OOP의 추상화와 관련있는 속성 ~

## 5.2 OCP - 개방 폐쇄 원칙
> SW Entity(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만 변경에 대해서는 닫혀있어야 한다.   
> 자신의 확장에는 열려있고, 주변의 변화에는 닫혀있어야 한다.

좋은 예시 : JDBC, 스프링 프레임워크
* JDBC 클라이언트는 DB가 오라클에서 MySQL로 바뀌어도 Connection 설정은 바뀌지 않음
* 내가 이해한 것 : 상속을 통해 기능은 확장하지만, 변경되지 않을 공통된 기능은 상위 클래스에 비치함으로서 변경 없이 사용하도록 함

개방 폐쇄 원칙 덕분에 객체지향 가장 큰 장점인 유연성, 재사용성, 유지보수성을 얻을 수 있음

## 5.3 LSP - 리스코프 치환 원칙
> 서브타입은 언제나 자신의 기반타입(base type)으로 교체할 수 있어야 한다.

객체지향의 상속이 만족해야 하는 조건 => 해당 조건을 지킨 프로그램이면 리스코프 치환 원칙을 잘 지킨 것.
* 하위클래스 is a kind of 상위클래스
* 구현클래스 is able to 인터페이스

```java
아버지 춘향이 = new 딸()   // 잘못된 LSP
동물 뽀로로 = new 펭귄()   // 잘 된 LSP
```
* 하위 클래스 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스 인스턴스 역할을 하는데 문제가 없어야 한다
* 하위 클래스가 상위 클래스 역할을 하는 데 문제 없어야 함

## 5.4 ISP - 인터페이스 분리 원칙
> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다

단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결 방법
* 특별한 경우가 아니라면 SRP를 적용한느 것이 더 좋은 해결책...
* ISP는 하나의 객체가 여러 인터페이스를 상속한 뒤, 특정 역할을 할 때 특정 인터페이스로 제한하는 것(ex: 여자친구 앞에서는 남자친구 인터페이스로 제한, 직장 상사 앞에서는 사원 인터페이스로 제한 등)
* 인터페이스는 작을수록 좋음 : 상위클래슨느 풍성할수록, 인터페이스는 작을수록 좋다. LSP에 따라 하위 객체는 상위 객체인 척 할 수 있다.
  * 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하는 것이 핵심.

## 5.5 DIP - 의존 역전 원칙
> 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.   
> 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.   
> 자주 변경되는 구체(Concrete)클래스에 의존하지 마라

의존 역전 원칙
* 자신보다 변하기 쉬운 것에 의존하던 것에 추상화된 인터페이스나 상위 클래스를 두어 **변하기 쉬운것에 변화에 영향받지 않게 하는 것**
* 자신보다 쉬운 것에 의존하지 마라 ~

## 질문
* SOILD를 각각 한 줄씩 설명
* OOP와 SOLID를 엮어서 설명해보시오
