# ch04. Go의 CPU 자원 사용법
## 4.1 최신 컴퓨터 구조의 CPU
- 다중 코어로 구성된 CPU
- 각 코어는 메모리 계층(RAM, 레지스터, L캐시)에 명령 실행 가능

언제 CPU 자원을 신경쓰게 될까?
- 프로세스가 사용 가능한 모든 CPU 자원을 사용해서 시스템이 다른 작업을 수행 불가
- 프로세스가 예기치않게 느리게 실행되면서 동시에 CPU 사용량이 높게 나타남

## 4.2 어셈블리어
CPU가 프로그램을 실행하는 방식을 이해하기 위해 어셈블리어를 공부해야함

Go pseudo 어셈블리어 -> Go 도구를 사용해서 `go tool objdump -S <바이너리>` 를 쓰는걸로 역어셈블링 할 수 있음 (어셈블리어->기계어)
```go
// go tool objdump -S sum.test
ret += num

```

CPU 모델마다 명령어 집합이 다르고 메모리 주소체계, 기타 부분이 달라 복잡히재는 문제
- ISA -> 프로그램을 x86 아키텍쳐용 ISA와 호환되는 기계어로 컴파일하고 모든 x86 CPU에서 실행 가능

## 4.3 Go 컴파일러 이해
빌드 방법은 대상 환경에 따라 다양함... -> Tiny Go는 마이크로컨트롤러용 바이너리 빌드 생성, gopherjs는 브라우저내 실행을 위한 자바스크립트...

`go build`
- 코드를 다양한 형태로 빌드 가능
- 공유 라이브러리나 C호환 공유 라이브러리도 만들 수 있으나, 모든 종속성이 정적으로 연결된 실행 파일을 빌드하ㅡㄴ걸 권장
- 컴파일과 링크를 모두 호출
- 한 번에 한 패키지에만 집중
- 효율적인 Go프로그램을 만들기 위해서는 컴파일러에 거스르지 말고 협업해야함
- 교차 컴파일모드로 C, C++, 포트란에서 구현된 함수를 Go 코드와 섞어 컴파일 가능
  - cgo 모드 활성 -> 빌드 성능때문에 권장 X

<img width="612" alt="image" src="https://github.com/user-attachments/assets/21aec671-e1fa-40e0-997a-9b8655ce29e4" />

1. Go 코드는 토큰으로 나뉘고 파싱된 뒤 구문검사 받음. 구문트리는 의미있는 에러와 디버깅 정보를 생성하기 위해 파일과 파일 내 위치를 참조
2. AST가 생성됨 -> 타입검사 받고 선언되었지만 사용하지 않은 항목 감지됨
3. 최적화의 첫 관문... 불필요한 코드 제거, 이스케이프 분석(스택에 배치 가능한 변수, 힙에 할당해야 할 변수 결정), 함수 인라인 수행 등

인라인
- 컴파일러는 일부 함수 호출을 본문의 정확한 복사본으로 자동 대체
- Go 1.9 부터 컴파일러는 스택 말단과 중간 함수를 모두 인라인 가능

## 4.4 CPU와 메모리 벽 문제

## 4.5 스케줄러

## 4.6 언제 동시성을 사용할 것인가

