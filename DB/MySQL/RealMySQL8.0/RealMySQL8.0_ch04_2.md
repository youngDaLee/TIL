# RealMySQL8.0 ch04. 아키텍쳐
## 4.2 InnoDB 스토리지 엔진 아키텍쳐
### 4.2.1 프라이머리 키에 의한 클러스터링
* InnoDB 모든 테이블은 PK 기준으로 클러스터링 되어 저장 => PK 순서로 저장
* 세컨더리 인덱스는 PK값을 논리적인 주소로 사용
* PK를 이용한 레인지 스캔은 다른 보조인덱스보다도 더 빠르게 처리됨

In MyISAM...
* 클러스터링 키를 지원하지 않기 때문에 PK는 단지 유니크한 인덱스일뿐... 기능 차이 없음

### 4.2.2 외래 키 지원
* MyISAM, MEMORY에서는 지원 X. InnoDB에서만 지원
* 운영의 불편함... 주의 필요
    * 수동 데이터 적재, 긴급 조치 등에서 외래키 때문에 불편할 수 있음 => 일시적으로 외래키 관계 체크 off 할 수 있음(`SET FOREIGN_KEY_CHECKS=OFF;`)
    * 다만 이 상태에서도 부모 레코드 삭제했으면 자식 레코드 삭제하는 등 일관성 유지시켜주어야함

### 4.2.3 MVCC(Multi-Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS가 지원하는 기능
* **잠금을 사용하지 않는 일관적 읽기 제공**
* InnoDB는 언두로그(Undo log)를 통해 MVCC를 구현
* MV(Multi Version) : 하나의 레코드에 대해 여러 버전이 동시에 관리됨

테이블에 한 건의 레코드가 INSERT되고 UPDATE 해서 발생하는 변경작업 및 절차
1. UPDATE 실행 시 커밋 실행 여부와 관련 없이 InnoDB 버퍼풀은 새로운 값으로 UPDATE
    * 디스크 데이터 파일은 업데이트 되었을 수도 있고 아닐 수도 있음(InnoDB가 ACID를 보장하기 때문에 일반적으로는 동일한상태)
2. 이 상태에서 레코드 조회 시, MySQL 시스템 변수(`transaction_isoloation`) 격리수준에 따라 다르게 처리
    * `READ_UNCOMMITED` : 가지고 있는 변경된 값으로 읽음(커밋 여부와 무관)
    * `READ_COMMITED` 이상(`REPEATABLE_READ`, `SERIALIZABLE`) : 언두영역 데이터 반환

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
* `SERIALIZABLE` 가 아닌 격리수준에서 `INSERT`와 연결되지 않은 순수한 `SELECT` 면 "잠금 없는 일관된 읽기(MVCC)"가 적용됨
* MVCC를 위해 활성상태인 트랜잭션에서는 언두로그를 삭제하지 않고 유지 => 서버가 느려지거나 문제 발생
  * 트랜잭션 시작했으면 가능한 빨리 롤백/커밋으로 트랜잭션 완료 시키는걸 권장

### 4.2.5 자동 데드락 감지
* InnoDB는 잠금이 데드락에 걸렸는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리
* 데드락 감지 스레드가 주기적으로 데드락을 검사하고 데드락 상태의 트랜잭션을 강제종료함
  * 강제종료 우선순위 트랜잭션 : 언두로그 양이 적은 트랜잭션
* 일반적으로 데드락 감지 스레드는 부담되지 않지만, 동시처리 스레드나 잠금 개수 많아지면 느려짐
* `innodb_deadlock_detect` : OFF로 설정하면 데드락 감지 스레드 작동 X => 데드락 무한정 대기 하므로 timeout 설정 권장
* `innodb_lock_wait_timeout` : 설정한 시간보다 오래 실행되면 쿼리는 실패하고 에러 리턴

### 4.2.6 자동화된 장애 복구
InnoDB는 MySQL서버가 시작될 때 완료되지 못한 트랜잭션을 복구하는 작업이 자동으로 진행됨  
-> 이 단계에서 복구될 수 없는 손상된 파일이 있으면 자동 복구 멈추고 서버 종료됨   
-> 이 때는 `innodb_force_recovery` 설정해서 서버 시작해야 함
* InnoDB 로그 파일 손상 : 6으로 설정
* InnoDB 데이터 파일 손상 : 1로 설정
* 문제 알 수 없음 : 1~6까지 변경하면서 재시작
* 0이 아닌 1~6의 복구에서는 SELECT 이외의 쿼리 수행 불가 => 복구된 후 mysqldump로 백업한 뒤 DB, 테이블 재생성하는 것을 권장

`innodb_force_recovery`
* 1 (SRV_FORCE_IGNORE_CORRUPT)
  * 테이블 스페이스, 인덱스 페이지에서 손상된 부분 발견되어도 무시하고 실행
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 2 (SRV_FORCE_NO_BACKGROUND)
  * 백그라운드 스레드 중 메인 스레드 시작하지 않고 MySQL 서버 시작
  * 메인 스레드가 언두데이터 삭제하는 과정에서 장애 발생한 경우 해당 모드로 복구
* 3 (SRV_FORCE_NO_TRX_UNDO)
  * 커밋되지 않은 트랜잭션 작업을 롤백하지 않고 놔둠
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 4 (SRV_FORCE_NO_IBUF_MERGE)
  * 인서트 버퍼 무시하고 강제로 서버 시작.
  * 인서트 버퍼는 실제 데이터와 관련된 부분이 아닌 인덱스 관련 부분이므로 테이블 덤프한 뒤 DB 구축하면 데이터 손실 없이 복구 가능
* 5 (SRV_FORCE_NO_UNDO_LOG_SCAN)
  * 언두로그 스캔하지 않고 강제로 서버 시작
  * 커밋되지 않은 데이터도 모두 커밋된것처럼 처리되어 잘못된 데이터가 DB에 남음
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 6 (SRV_FORCE_NO_LOG_REDO)
  * 리두로그 무시하고 서버 시작
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장

### 4.2.7 InnoDB 버퍼 풀
InnoDB 핵심 부분. 디스크 데이터 파일, 인덱스 정보를 메모리에 캐싱하는 공간. 쓰기 작업을 일괄 지연시켜 버퍼링 하는 역할도 함.

#### 4.2.7.1 버퍼풀 크기 설정
* `innodb_buffer_pool_size` : InnoDB 버퍼풀 크기 설정
  * 50% 이상 설정 권장. 50%에서 조금씩 올리면서 적절한 값 찾기
  * 80% 이상 설정하면 버퍼풀이 너무 커져서 메모리 부족으로 서버가 다운될 수 있음

#### 4.2.7.2 버퍼 풀 구조
버퍼풀을 페이지 크기 조각으로 쪼개 관리.
* LRU(Least Recently Used) List
  * 한 번 읽어온 페이지를 최대한 오랫동안 버퍼풀 메모리에 유지해서 디스크 읽기를 최소화 함
  * 버퍼풀에 상주하는 데이터는 쿼리가 최근 접근했는지에 따라 나이(age)가 부여됨. 오래 접근하지 않을수록 늙어지고, 늙은 데이터는 제거됨. 젋은 데이터는 헤더로 옮겨짐
* Flush List
  * 디스크로 동기화 되지 않은 데이터 페이지 목록을 관리
* Free List

#### 4.2.7.3 버퍼 풀과 리두로그
InnoDB 버퍼풀과 리두로그는 밀접한 관계가 있다.
* InnoDB 버퍼풀은 변경안된 클린페이지/변경된데이터 가진 더티페이지로 구분됨. 더티페이지는 버퍼풀에 무한정 남을 수 없음.
* 리두로그에서 재사용 불가능한 공간을 활성 리두로그라고 함.
* 리두로그 파일 공간은 순환되어 재사용되고, 기록될 때 마다 로그 포지션이 증가(LSN). 주기적으로 체크포인트 이벤트를 발생시켜 리두로그와 버퍼풀 더티페이지를 디스크로 동기화함
* 체크포인트에이지 = 활성리두공간 크기

=> 버퍼풀 더티페이지는 특정 리두로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 LSN보다 작은 리두로그 엔트리와 관련된 더티페이지가 모두 디스크로 동기화 되어야 함.

감은 잘 안오지만 내가 이해한 것...
* 버퍼풀의 더티페이지는 디스크로 기록이 되어야 하는 일종의 후보.
* 버퍼풀의 더티페이지들은 리두로그와 관계를 가짐.
* 체크포인트가 발생하면, 마지막으로 기록된 리두로그(LSN) 이하의 모든 데이터가 디스크에 기록됨.
* 리두로그가 작으면 체크포인트가 자주 발생하니까 디스크 접근이 잦아짐
* 리두로그가 너무 크면 갑작스럽게 디스크에 너무 많은 쓰기 작업이 몰릴 수 있음

#### 4.2.7.4 버퍼 풀 플러시(Buffer Pool Flush)
InnoDB는 더티페이지 디스크 동기화 관리를 위해 2개 플러시 기능을 백그라운드로 실행함
* 플러시 리스트(Flush_list) 플러시
  * 리두로그 재활용을 위해 오래된 리두로그 공간을 비워야 함. 그러기 위해서는 버퍼풀 더티페이지가 먼저 동기화 되어야 함.
  * 플러시리스트 플러시가 순서대로 오래전에 변경된 데이터 페이지를 디스크에 동기화 시켜줌
  * 더티페이지가 많을수록 Disk IO Burst 현상 발생 가능. => 발생 방지 위해 일정 수준 이상 더티페이지 발생하면 조금씩 디스크로 기록.
* LRU 리스트(LRU_list) 플러시
  * 사용 빈도가 낮은 데이터페이지를 제거해서 새로운 페이지를 읽을 공간 확보하는 함

#### 4.2.7.5 버퍼풀 상태 백업 및 복구
* 5.6 버전부터 버퍼풀 덤프/적재 기능 도입 => 이전까지는 서버 재시작시 강제로 풀스캔 시켜서 워밍업 시켜주는 과정이 필요했음
* 버퍼풀 백업은 `innodb_buffer_pool` 로 파일 생성됨.

#### 4.2.7.6 버퍼풀 적재 내용 확인
5.6 버전부터 `information_schema` 테이블에서 버퍼풀 메모리에 어떤 테이블 페이지 적재되었는지 확인 가능


### 4.2.8 Double Write Buffer
* InnoDB의 리두로그는 공간 낭비 방지를 위해 페이지 변경 내용만 기록함 => 스토리지 엔진에서 더티페이지 디스크 파일 플러시 할 때 일부만 기록되어 문제 발생하면 복구 불가할수도....
  * Torn-page(혹은 Partial-page) 현상. 하드웨에어 오작동, 시스템 비정상 종료로 발생 가능
* 위 문제 방지 위해 Double-Write 기법 이용
* 실제 데이터 파일에 변경 내용 기록 전 기록할 더티페이지를 묶어서 시스템 테이블 스페이스의 Double-Write 버퍼에 기록.
* 이후 스토리지 엔진이 적절한 위치에 랜덤으로 쓰기 실행함.
* 비정상 종료된 후 재시작되면 Double-Write 버퍼와 데이터 파일 비교해서 다른 내용을 담고 있다면 Double-Write qjvjfmf epdlxjvkdlffh qhrtkgka.
* HDD는 별 부담 되지 않지만 SSD는 부담스러움... 이때는 무결성이 중요한 서비스에서만 DoubleWrite 활성화를 권장함

### 4.2.9 언두로그
트랜잭션 격리수준을 위해 DML 변경 전 데이터를 별도의 데이터로 복구 => 언두로그
* 트랜잭션 보장 : 트랜잭션 롤백 시 트랜잭션 발생 전 데이터로 복구해야 하는데, 이때 언두로그가 사용됨
* 격리수준 보장 : 특정 커넥션에서 데이터 변경 시, 다른 커넥션에서 해당 데이터 조회할 때 격리수준에 따라 언두로그 데이터를 읽음

#### 4.2.9.1 언두로그 레코드 모니터링
* 5.5 이전 버전에서는 한번 증가한 언두로그 공간은 줄어들지 않았음. => 대용량 트랜잭션, 오랫동안 실행되는 트랜잭션에서 용량 이슈 발생
* 5.7 ~ 8.0 부터는 언두로그 공간 문제 해결.

#### 4.2.9.2 언두로그 테이블스페이스 관리
* 언두로그 테이블스페이스 : 언두로그가 저장되는 공간
* 8.0 이전까지는 한 번 생성된 언두로그는 변경 허용X, 이후부터는 언두테이블 스페이스를 동적으로 추가/삭제 가능
* 언두테이블 불필요한 공간을 잘라내는 방법(8.0부터 지원)
  * 자동모드
  * 수동모드

### 4.2.10 체인지 버퍼
변경해야 할 인덱스 페이지가 버퍼풀에 있으면 바로 업데이트 하지만, 그렇지 않고 디스크로부터 읽어와서 업데이트 해야 한다면 즉시 수행하는게 아니라 임시 공간에 저장하고 사용자에게 결과를 반환하는 형태로 성능 향상
 => 이 때 사용하는 임시 메모리 공간이 체인지 버퍼



## 질문
* 테이블 덤프와 mysqldump로 덤프하는 것의 차이가 무엇인가