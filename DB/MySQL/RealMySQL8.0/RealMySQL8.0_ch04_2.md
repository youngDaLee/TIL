# RealMySQL8.0 ch04. 아키텍쳐
## 4.2 InnoDB 스토리지 엔진 아키텍쳐
### 4.2.1 프라이머리 키에 의한 클러스터링
* InnoDB 모든 테이블은 PK 기준으로 클러스터링 되어 저장 => PK 순서로 저장
* 세컨더리 인덱스는 PK값을 논리적인 주소로 사용
* PK를 이용한 레인지 스캔은 다른 보조인덱스보다도 더 빠르게 처리됨

In MyISAM...
* 클러스터링 키를 지원하지 않기 때문에 PK는 단지 유니크한 인덱스일뿐... 기능 차이 없음

### 4.2.2 외래 키 지원
* MyISAM, MEMORY에서는 지원 X. InnoDB에서만 지원
* 운영의 불편함... 주의 필요
    * 수동 데이터 적재, 긴급 조치 등에서 외래키 때문에 불편할 수 있음 => 일시적으로 외래키 관계 체크 off 할 수 있음(`SET FOREIGN_KEY_CHECKS=OFF;`)
    * 다만 이 상태에서도 부모 레코드 삭제했으면 자식 레코드 삭제하는 등 일관성 유지시켜주어야함

### 4.2.3 MVCC(Multi-Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS가 지원하는 기능
* **잠금을 사용하지 않는 일관적 읽기 제공**
* InnoDB는 언두로그(Undo log)를 통해 MVCC를 구현
* MV(Multi Version) : 하나의 레코드에 대해 여러 버전이 동시에 관리됨

테이블에 한 건의 레코드가 INSERT되고 UPDATE 해서 발생하는 변경작업 및 절차
1. UPDATE 실행 시 커밋 실행 여부와 관련 없이 InnoDB 버퍼풀은 새로운 값으로 UPDATE
    * 디스크 데이터 파일은 업데이트 되었을 수도 있고 아닐 수도 있음(InnoDB가 ACID를 보장하기 때문에 일반적으로는 동일한상태)
2. 이 상태에서 레코드 조회 시, MySQL 시스템 변수(`transaction_isoloation`) 격리수준에 따라 다르게 처리
    * `READ_UNCOMMITED` : 가지고 있는 변경된 값으로 읽음(커밋 여부와 무관)
    * `READ_COMMITED` 이상(`REPEATABLE_READ`, `SERIALIZABLE`) : 언두영역 데이터 반환

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
* `SERIALIZABLE` 가 아닌 격리수준에서 `INSERT`와 연결되지 않은 순수한 `SELECT` 면 "잠금 없는 일관된 읽기(MVCC)"가 적용됨
* MVCC를 위해 활성상태인 트랜잭션에서는 언두로그를 삭제하지 않고 유지 => 서버가 느려지거나 문제 발생
  * 트랜잭션 시작했으면 가능한 빨리 롤백/커밋으로 트랜잭션 완료 시키는걸 권장

### 4.2.5 자동 데드락 감지
* InnoDB는 잠금이 데드락에 걸렸는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리
* 데드락 감지 스레드가 주기적으로 데드락을 검사하고 데드락 상태의 트랜잭션을 강제종료함
  * 강제종료 우선순위 트랜잭션 : 언두로그 양이 적은 트랜잭션
* 일반적으로 데드락 감지 스레드는 부담되지 않지만, 동시처리 스레드나 잠금 개수 많아지면 느려짐
* `innodb_deadlock_detect` : OFF로 설정하면 데드락 감지 스레드 작동 X => 데드락 무한정 대기 하므로 timeout 설정 권장
* `innodb_lock_wait_timeout` : 설정한 시간보다 오래 실행되면 쿼리는 실패하고 에러 리턴

### 4.2.6 자동화된 장애 복구
InnoDB는 MySQL서버가 시작될 때 완료되지 못한 트랜잭션을 복구하는 작업이 자동으로 진행됨  
-> 이 단계에서 복구될 수 없는 손상된 파일이 있으면 자동 복구 멈추고 서버 종료됨   
-> 이 때는 `innodb_force_recovery` 설정해서 서버 시작해야 함
* InnoDB 로그 파일 손상 : 6으로 설정
* InnoDB 데이터 파일 손상 : 1로 설정
* 문제 알 수 없음 : 1~6까지 변경하면서 재시작
* 0이 아닌 1~6의 복구에서는 SELECT 이외의 쿼리 수행 불가 => 복구된 후 mysqldump로 백업한 뒤 DB, 테이블 재생성하는 것을 권장

`innodb_force_recovery`
* 1 (SRV_FORCE_IGNORE_CORRUPT)
  * 테이블 스페이스, 인덱스 페이지에서 손상된 부분 발견되어도 무시하고 실행
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 2 (SRV_FORCE_NO_BACKGROUND)
  * 백그라운드 스레드 중 메인 스레드 시작하지 않고 MySQL 서버 시작
  * 메인 스레드가 언두데이터 삭제하는 과정에서 장애 발생한 경우 해당 모드로 복구
* 3 (SRV_FORCE_NO_TRX_UNDO)
  * 커밋되지 않은 트랜잭션 작업을 롤백하지 않고 놔둠
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 4 (SRV_FORCE_NO_IBUF_MERGE)
  * 인서트 버퍼 무시하고 강제로 서버 시작.
  * 인서트 버퍼는 실제 데이터와 관련된 부분이 아닌 인덱스 관련 부분이므로 테이블 덤프한 뒤 DB 구축하면 데이터 손실 없이 복구 가능
* 5 (SRV_FORCE_NO_UNDO_LOG_SCAN)
  * 언두로그 스캔하지 않고 강제로 서버 시작
  * 커밋되지 않은 데이터도 모두 커밋된것처럼 처리되어 잘못된 데이터가 DB에 남음
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장
* 6 (SRV_FORCE_NO_LOG_REDO)
  * 리두로그 무시하고 서버 시작
  * mysqldump 등을 이용해서 덤프한뒤 DB 재생성 권장

### 4.2.7 InnoDB 버퍼 풀


## 질문
* 테이블 덤프와 mysqldump로 덤프하는 것의 차이가 무엇인가