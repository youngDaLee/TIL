# RealMySQL8.0 ch05. 트랜잭션과 잠금
* 트랜잭션 : 작업의 완전성을 보장. 논리적인 작업을 완전히 처리하지 못할 경우 원상태로 복구시켜주는 것.
* 잠금 : 동시성 제어
* 격리수준 : 하나의 트랜잭션 내, 혹은 여러 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할것인지 결정하는 레벨

## 5.1 트랜잭션
### 5.1.1 MySQL 에서의 트랜잭션
* 트랜잭션 : 하나의 논리적인 작업셋이 100% 적용되거나(COMMIT), 아무것도 적용되지 않아야(ROLLBACK)함을 보장
* 트랜잭션을 보장하지 않는 MyISAM은 쿼리 실행도중 오류가 발생해도 이전 쿼리들이 적용되는 반면, InnoDB는 전체가 적용되지 않음

### 5.1.2 주의사항
* 트랜잭션을 최소화 해라
  * 데이터베이스 커넥션은 개수가 제한적이기 때문에 트랜잭션이 커넥션을 소유하는 시간이 길어질 수록 다른 트랜잭션에서 기다려야 하는 상황 발생
  * 네트워크를 통해 통신하는 작업을 다른 작업과 트랜잭션으로 묶어버리면 에러 발생 시 서버까지 위험해지는 상황 발생할지도...
* 결론 : 프로그램 코드가 커넥션 가지고 있는 범위와 트랜잭션 활성화 범위를 최소화해라~

## 5.2 MySQL 엔진의 잠금
잠금
* 스토리지 엔진 레벨
* MySQL 엔진 레벨 : 스토리지 엔진을 제외한 나머지 부분.

MySQL 엔진 레벨 잠금은 모든 스토리지 엔진 레벨 잠금에 영향을 미치지만, 스토리지 엔진 잠금은 잠금 간 영향을 미치지 않음.

### 5.2.1 글로벌 락 (GLOBAL LOCK)
* `FLUSH TABLES WITH READ LOCK` 명령으로 획득
* MySQL 잠금 중 가장 범위가 큰 잠금
* 한 세션에서 글로벌 락을 획득하면, SELECT 제외 대부분의 DDL,DML문장이 락 해제 전까지 대기 상태로 남음
    * 모든 변경 작업을 멈춤
* 8.0 부터는 백업락 도입됨
  * DB, 테이블 생성 변경 삭제 불가
  * REPAIR TABLE, OPTIMIZE TABLE 불가
  * 사용자 관리, 비밀번호 변경 불가
  * **일반적인 테이블 데이터 변경은 가능** -> 백업 도중 DDL 쿼리 실행되어도 백업 실패하지 않기 위해...

### 5.2.2 테이블 락 (TABLE LOCK)
* 개별 테이블 단위 락
* 명시적으로는 `LOCK TABLES table_name [READ|WRTIE]` 로 확득, `UNLOCK TABLES` 로 해제
  * 특별한 상황이 아니면 애플리케이션에서 사용할 필요 없음 -> 온라인 작업에 영향..
* 묵시적으로는 MyISAM, MEMORY 테이블에 데이터 변경하는 쿼리 실행 시 발생. 쿼리 실행 시 자동 획득했다가 ㄲ트나면 반환
* InnoDB는 레코드 단위 락 지원하기 때문에 DML에서는 무시되고 DDL같이 스키마 변경하는 쿼리에만 영향 끼침

### 5.2.3 네임드 락(Named Lock)
* `GET_LOCK()` 함수로 임의의 문자열에 대해 잠금을 설정 가능 / `RELEASE_LOCK()` 으로 해제
  * 사용자가 지정한 문자열(string)에 대해 획득, 반납
  * 많은 레코드에서 한 번에 많은 레코드 변경하는 트랜잭션에 유용하게 동작... => 데이터를 변경, 참조하는 프로그램끼리 분류해서 네임드락 걸고 쿼리 실행
* 8.0 부터 네임드락 중첩 실행 가능

### 5.2.4 메타데이터 락(Metadata Lock)
* DB객체(테이블, 뷰 등)의 이름이나 구조를 변경하고자 할 때 획득하는 잠금.
* 명시적으로 획득 할 수 없고 `RENAME TABLE tab_a TO tab_b` 등 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금

## 5.3 InnoDB 스토리지 엔진의 잠금
InnoDB는 MySQL에서 제공하는 락과 별개로 스토리지 엔진 내부에서 레코드 기반 잠금을 탑재함. => MyISAM보다 뛰어난 동시성 처리 제공

### 5.3.1 InnoDB 스토리지 엔진의 잠금
InnoDB의 레코드 기반 잠금은 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드락이 페이지락/테이블락으로 레벨업되는 경우(락 에스컬레이션)는 없다. 
InnoDB 스토리지 엔진에는 레코드 사이 간격을 잠그는 갭 락도 존재함. 

<img width="280" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/efba730f-7ebc-4694-b5a6-3ad112c16ee1">

#### 5.3.1.1 레코드락(Record Lock)
* 레코드 자체만을 잠그는 것.
* 레코드 자체가 아니라 인덱스의 레코드를 잠금 => 인덱스가 없는 테이블은 내부적으로 자동 생성된 클러스터 인덱스를 잠금
* 보조인덱스를 이용한 변경 작업은 넥스트 키 락, 갭 락을 사용하지만 PK, 유니크 인덱스에 의한 변경 작업은 **갭락 없이 레코드 락만 건다**

#### 5.3.1.2 갭 락
* 레코드와 인접한 레코드 사이의 간격만을 잠그는 것. 다른 DBMS와의 차이점 ~
* 갭락의 역할 : 레코드 사이 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
  * 그 자체보다는 넥스트 키 락 일부로 사용됨

#### 5.3.1.3 넥스트 키 락
* 레코드락 + 갭락
* STATEMENT 포멧 바이너리 로그 사용하는 MySQL에서 REPEATABLE READ 격리 수준을 사용해야 함
* `innodb_locks_unsafe_for_binlog` 시스템 변수가 0으로 설졍되면(비활) 변경 위해 검색하는 레코드에서 넥스트 키 락 잠금 걸림
* 목적 : 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때, 소스 서버에서 만들어낸 결과와 동일한 결과를 만들도록 보장
  * 데드락 발생, 다른 트랜잭션 대기의 원인이 되기도... => 바이너리 로그 포맷을 ROW 형태로 바뀌서 넥스트 키락/갭락을 줄이는게 좋음

#### 5.3.1.4 자동 증가 락
* `AUTO_INCREMENT` 가 동시에 여러 번 INSERT 되는 경우 중복 없이 일정한 순서로 증가하는 값을 갖게 하기 위한 락
* INSERT, REPLACE 등 새로운 레코드 저장 쿼리에서만 실행되고, UPDATE, DELETE 등의 쿼리에서는 걸리지 않음
* 트랜잭션과 관련 없이 INSERT, REPLACE 에서만 걸렸다가 해제됨
* 테이블에 하나만 존재함 -> 일시적으로 걸렸다가 사라지니까 문제 되는 경우 거의 없음...
  * `innodb_autoinc_lock_mode=0` : 5.0과 동일한 방식으로 모든 INSERT가 자동증가 락
  * `innodb_autoinc_lock_mode=1` : 여러 건 INSERT 될 때, INSERT 되는레코드 건 수 없을때 만 자동증가 락. 그 외에 경우는 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 처리
  * `innodb_autoinc_lock_mode=2` : 무조건 경량화된 래치(뮤텍스) 사용 => 하나의 INSERT라도 연속된 자동증가 값을 보장하지 않음

### 5.3.2 인덱스와 잠금

### 5.3.3 레코드 수준의 잠금 확인 및 해제

## 5.4 MySQL의 격리 수준

## 질문
* 네임드락을 쓰는 예가 잘 생각이 안남
* 레코드락에서 보조인덱스를 이용하면 넥스트키락, 갭락 쓰는데 PK쓰면 갭락 안쓴다는게 SELECT 조건에 쓴다는건지, 그 인덱스를 바꾼다는건지가 이해가 안됨
* 넥스트 키 락이 왜 데드락과 트랜잭션 대기의 원인이 되는지
