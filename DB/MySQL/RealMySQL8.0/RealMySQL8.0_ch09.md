# ch09. 옵티마이저와 힌트
## 9.1 개요
어떤 DBMS든 쿼리 실행 계획 수립하는 옵티마이저가 가장 복잡한 부분으로 알려져있음... 
옵티마이저가 만들어내는 실행계획을 이해해야 불합리한 부분을 찾아내고 더 나은 실행계획으로 유도할 수 있음
### 9.1.1 쿼리 실행 절차
MySQL에서 쿼리가 실행되는 과정
1. 사용자로부터 SQL을 쪼개 MySQL서버가 이해할 수 있는 수준으로 분리(파스 트리) : SQL 파싱 -> SQL의 잘못된 문장이 걸러짐
2. SQL 파싱 정보(파스트리)를 확인하며 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블 읽을지 선택 : 최적화 및 계획 수립 ->  1번의 파스트리를 이용해 처리
    * 불필요한 조건 제거, 연산 단순화
    * 여러 테이블 조인이 있는 경우 어떤 순서로 테이블 읽을지 결정
    * 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결졍
    * 가져온 레코드를 임시 테이블에 넣고 다시 가공해야 하는지 결정
3. 두번째 단계에서 결정된 테이블 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

1, 2는 MySQL 엔진에서 처리하고, 3은 MySQL 엔진과 스토리지 엔진이 동시에 참여함

### 9.1.2 옵티마이저 종류
서버 두뇌 역할. 대부분의 DBMS가 선택하는 비용 기반 최적화(CBO) 방법과, 초기 DBMS에서 사용한 규칙 기반 최적화(RBO)로 나뉘님
* 규칙 기반 최적화(Rule-based optimizer, RBO) : 대상 테이블 레코드 건수나 선택도를 고려하지 않고, 옵티마이저에 내장된 우선순위에 따라 실행계획 수립. 통계 정보(테이블 레코드 건수/컬럼값 등)를 조사하지 않고 실행계획이 수립하기 때문에, 같은 쿼리에 대해 같은 실행 방법을 만들어냄. => 사용자 데이터 분포가 다양하기 때문에 규칙 기반 최적화는 이미 오래 전 부터 거의 사용 안함
* 비용 기반 최적화(Cost-based optimizer, CBO) : 쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업 비용 정보와 대상 테이블 예측 통계 정보를 이용해 실행계획별 비용 산출. 산출된 실행 방법 별로 비용 최소로 소요되는 처리 방식 선택해 최종 쿼리 선택

규칙 기반 최적화는 테이블 인덱스, 통계 정보 거의 없고 느린 CPU 연산 때문에 사용된 최적화 방법.. 현재 대부분은 비용 기반 최적화 기법 사용

## 9.2 기본 데이터 처리

### 9.2.4 GROUP BY 처리
* ORDER BY와 같이 스트리밍된 처리를 할 수 없게 하는 처리
* GROUP BY 절 쿼리의 HAVING절은 GROUP BY 필터링 역할을 수행함.
* GROUP BY 조건은 인덱스 처리 될 수 없으므로 HAVING절 튜닝하려고 인덱스 생성 할 필요 없음

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
* 조인 드라이빙 테이블에 속한 컬럼만 이용해 그루핑 할 때, GROUP BY 컬럼에 인덱스가 있으면 인덱스를 차례로 읽으며서 그루핑 수행
* GROUP BY 인덱스를 쓰더라도 그룹 함수등의 그룹값을 처리해야 해서 임시 테이블이 필요 할 수 도 있음

#### 루스 인덱스 스캔을 이용하는 GROUP BY

#### 임시테이블 사용하는 GROUP BY

## 9.3 고급 최적화

## 9.4 쿼리 힌트

