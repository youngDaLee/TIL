# RealMySQL8.0 ch08. 인덱스

## 8.1 디스크 읽기 방식
랜덤IO, 순차(Sequential)IO 와 같은 디스크 읽기 방식은 인덱스와 연관이 있다~
DB 성능 튜닝은 DiskIO를 줄이느냐가 관건일 때가 상당히 많다.

### 8.1.1 HDD와 SSD
* SSD(Solid State Drive) : 기계식 HDD를 대체하기 위한 전자식 저장 매체. 기존 HDD와 같은 인터페이스(SATA, SAS)를 지원하므로 DAS나 SAN에 그대로 사용 가능
  * 기존 HDD에서 데이터 저장용 플래터(원판)를 제거하고 플래시 메모리를 장착 => 원판이 없어져 매우 빠르게 데이터 릭고 쓸 수 있음
  * D-RAM보다는 느리지만 HDD보다는 훨씬 빠르다
  * HDD보다 용량이 적고 비싸지만 전보다는 대중화되어 DBMS용으로 많이 사용함
* 헤더를 움직이지 않고 한 번에 많은 데이터 읽는 순차IO에서는 HDD가 조금 빠르거나 같다.
* 랜덤IO는 SSD가 훠어어얼씬 빠르다
* 일반적인 웹서비스(OLPT)환경에서는 SSD가 HDD보다 훨씬빠르다

### 8.1.2 랜덤IO와 순차IO
* 랜덤IO : HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 헤더를 이동시켜 읽는 것
  * 랜덤 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 3번 움직임
* 순차IO : 과정은 랜덤과 같지만, 헤더 이동시키는 정도가 다름...
  * 순차 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 1번 움직임

=> 여러 번 읽기/쓰기를 요청하는 랜덤IO작업 부하가 크다. 그런데 DB 대부분은 랜덤IO가 일어나므로, MySQL서버에서 자체적으로 바이너리 로그 버퍼나, InnoDB버퍼 등 기능이 내장됨.
* SSD은 랜덤/순차 차이가 거의 없어도 결국 전체 throughput이 떨어짐
  * throughput: 단위시간당 데이터 전송 처리량
* 쿼리를 튜닝해서 랜덤IO를 순차IO로 바꿔서 실행할 수 없음.. 쿼리 튜닝 자체가 랜덤IO 자체를 줄이는 것 = 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는것
  * 그~래도 대체적으로 인덱스 레인지 스캔은 랜덤IO를 사용하고 풀스캔은 순차IO를 사용함. 큰 테이블 대부분 데이터를 읽는 작업은 풀스캔을 유도하도록 하는데, 순차IO가 랜덤IO보다 빨리 많은 레코드를 읽게 함(=OLTP보다는 데이터 웨어하우스나 통계작업 등에서 사용되는 쿼리...)

## 8.2 인덱스란?
* 컬럼(들)의 값과, 레코드 주소를 key-value 형태로 저장한 형태
* 컬럼(들) 값을 미리 주어진 형태로 정렬되어 저장
* 자료구조로 비유
  * Sorted List : 인덱스 = insert는 느리고 find는 빠름
  * Array List : 데이터파일 = find는 느리고 insert는 빠름
* 인덱스 = 저장(INSERT, UPDATE, DELETE) 성능 희생하고 SELECT 속도 높이는 기능

인덱스의 구분
* Primary Key(PK, 식별자): NULL과 중복을 허용하지 않음. 해당 레코드를 식별할 수 있는 기준값.
* Secondary Index(Secondary Key, 보조키): PK를 제외한 모든 인덱스. UK(유니크 인덱스)는 PK와 성격이 비슷해서 대체키라고 하기도 함.

인덱스 저장 방식(알고리즘)별 구분
* B-Tree : 일반적인 인덱싱 알고리즘. 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱 하는 방법
* Hash : 컬럼을 해싱해서 인덱싱하는 방법. Prefix와 같이 일부 검색하거나 범위 검색(레인지 스캔)할 때는 해시 인덱스가 사용되지 않는다. Redis와 같은 메모리 기반 DB에서 많이 사용함
  * Redis 디폴트가 Hash로 알고있음... 따라서 키를 검색할 때 Prefix 검색( `keyword*` )을 하면 어어어엄청 성능 떨어지는 것으로 인지하고 있다.
* 그 외 기타등등..(R-Tree, Fractal-Tree, Merge-Tree 등)

## 8.3 B-Tree 인덱스
인덱싱 알고리즘 중 가장 많이 사용되고 가장 먼저 도입되었고, 가장 범용적으로 사용되고 있는 알고리즘. 원래 값을 변형하지 않고 항상 정렬된 상태로 유지하는 알고리즘. 
B-Tree의 B는 Binary가 아니라 **Balanced** 이다.

### 8.3.1 구조 및 특성
<img width="558" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/fdc41a32-0bfc-4b67-a611-07ca806b06a3">

* 트리 최상위에 하나의 Root node 존재, 하위에 자식노드들 붙은 형태. 최하위에 있는 노드는 Leaf Node, 중간 노드는 Branch Node라 함.
* Leaf Node에는 항상 **실제 데이터 레코드 주소** 를 가지고 있음
* 인덱스 키 값은 모두 정렬되어 있지만 데이터 파일 레코드 임의의 순서로 저장되어 있음(삭제된 공간 재활용 하기 때문에 꼭 순서대로 저장되는것도 아님...)

InnoDB vs MyISAM
* MyISAM : 레코드 주소로 ROWID를 저장.
  * 세컨더리 인덱스를 생성하면 ROWID를 기준으로 찾기 때문에 데이터의 물리적인 주소를 저장함
* InnoDB : PK가 ROWID역할을 함.
  * 세컨더리 인덱스를 생성하면 PK를 저장하기 때문에 논리적인 주소를 저장함
  * 논리적인 주소(PK)를 갖기 때문에, 인덱스를 통한 읽기에서 레코드를 바로 찾지 못하고 PK를 통해 B-Tree를 한번 더 탄다.
* => InnoDB가 성능 떨어지는거 아니야? = 아님... 8.8 클러스터링 인덱스에서 추가 설명

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
인덱스 키 추가
* 스토리지 엔진에 따라 즉시 인덱스에 저장 될 수도 있고, 아닐수도 있음
* 저장될 키값을 이용해 B-Tree상 적절한 위치를 검색
* 저장될 위치 결정되면 대상 레코드 주소 정보를 B-Tree 리프노드상에 저장
* 리프노드가 꽉 차면 리프노드 분리(split) => 이런 작업 때문에 쓰기작업에 비용 많이 드는걸로 알려짐...
* INSERT, UPDATE 성능 변화 정확히 예측하려면 컬럼 수, 컬럼 크기, 컬럼 특성등을 고려해야하지만..
  * 대략적으로는 레코드를 추가하는 작업 비용을 1이라 할 때, 인덱스 추가하는 작업을 1.5 정도로 예측함.
  * 인덱스 하나도 없는 경우 작업 비용 1
  * 인덱스 3개가 있는 경우는 5.5(1.5*3 + 1)정도 비용이 드는 것으로 예측
  * => 비용 대부분이 메모리/CPU가 아닌 디스크로부터 인덱스 페이지 읽고쓰기 하는데 걸리는 시간
* MyISAM, MEMORY : INSERT 실행 즉시 B-Tree 값 변경
* InnoDB : 인덱스 키 추가 작업 지연처리...(PK, UK는 중복체크 필요해서 즉시 처리) => 4.2.10 참고

인덱스 키 삭제
* B-Tree 리프노드 찾아서 삭제 마크만 하면 작업 완료
* 삭제 마킹된 공간은 방치되거나 재사용됨.
* 삭제 마킹 작업이 필요하므로 diskIO 필요한 작업...
* InnoDB에서는 INSERT/UPDATE와 같이 버퍼링 처리(지연 처리) 가능
* MyISAM, MEMORY는 체인지버퍼 같은 기능이 없어서 디스크 작업 완료된 후에 쿼리 실행 완료됨

인덱스 키 변경
* B-Tree 키값이 변경되는 경우에는 단순 인덱스상 키값만 변경하는게 불가능...
  * 키값 삭제하고 새로운 키값 추가하는 형태로 처리됨
* 추가/삭제와 마찬가지로 InnoDB는 버퍼링 가능, 나머지는 불가...

인덱스 키 검색
* 쓰기(추가,삭제,변경) 비용 감당하면서 인덱스를 쓰는 이유...
* B-Tree 루트노드부터 브랜치노드를 거쳐 최종 리프노드까지 이동하며 비교작업 수행 = 트리탐색
* B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우 사용
* 인덱스 값에 변형이 가해진 경우는 B-Tree 인덱스 사용 불가
* InnoDB에서의 인덱스...
  * 레코드 잠금, 갭락이 검색 수행 후 검색한 인덱스 잠그고 테이블 레코드 잠그는 방식으로 구현됨
  * 따라서 UPDATE, DELETE 수행 후 테이블에서 사용할 수 있는 인덱스 없으면 불필요하게 많은 인덱스를 잠금
  * 내가 이해한 것 : 레코드 잠금과 갭락이 update/delete 할 때 작업을 위해 읽은 레코드를 모두 잠그므로, 읽는 레코드 수를 줄여야 하기 때문에 인덱스가 필요함

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스 키 값의 크기
* Page(Block)
  * InnoDB에서 디스크에 데이터를 저장하는 가장 기본 단위.
  * 디스크 읽기쓰기의 최소 작업 단위. InnoDB 버퍼풀에서 데이터 버퍼링하는 기본 단위.
  * 리프노드를 구분한 기준
* B-Tree는 자식노드 개수가 가변적(이진트리 아님!!!)
* B-Tree의 자식노드 수 : 인덱스 페이지 크기와 키값 크기에 따라 결정됨
  * `innodb_page_size` 를 통해 4KB ~ 64KB 선택(디폴트 16KB)
  * a) page_size 16KB인 인덱스에서, 인덱스 키가 16바이트, 자식노드 주소가 12바이트라면 하나의 인덱스 페이지(16KB)에 자식노드 수 585개(16*1024/(16+12)) 가질 수 있는 B-Tree
  * b) page_size 16KB인 인덱스에서, 인덱스 키가 32바이트, 자식노드 주소가 12바이트라면 하나의 인덱스 페이지(16KB)에 자식노드 수 372개(16*1024/(32+12)) 가질 수 있는 B-Tree
  * SELECT 쿼리가 500개 레코드 읽어야 할 때 a)는 한 개의 페이지로 해결 될 수 있지만, b)는 최소 2번 이상 읽어야 함 => 디스크로부터 읽는 개수 늘어나고, 그만큼 느려짐
  * 인덱스 크기가 커지면 버퍼풀에 저장할 수 있는 레코드가 적어짐. => 메모리 효율 떨어짐

B-Tree 깊이
* B-Tree Depth는 중요하지만 제어할 수 있는 방법이 없음
* B-Tree 깊이가 3인 경우 키값이 16바이트면 약 2억개(585 * 585 * 585), 32바이트면 약 5천만개(372 * 372 * 372).
* B-Tree 깊이 = 값 검색할 때 몇 번이나 랜덤하게 디스크 읽어야 하는지
* 인덱스 키 값 커질수록 하나의 페이지가 담을 수 있는 키 값 개수 적어지고, 같은 레코드 건수더라도 B-Tree 깊이가 깊어져 더 많은 디스크 읽기가필요
* 결론 : 인덱스 크기 작게 만들자~

선택도(기수성)
* 선택도(selectivity) = 기수성(cardinailty) 인덱스에서 거의 같은 의미로 사용됨.
* 인덱스 키 값 가운데 유니크한 값의 수. 키값 중 중복된 값이 많으면 기수성/선택도가 떨어짐
* 선택도(기수성)이 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리됨

읽어야 하는 레코드 건수
* 인덱스를 통해레코드 읽는 건, 인덱스 거치지 않고 읽는 것 보다 높은 비용이 든다.
* 인덱스를 이용한 읽기의 손익분기점
  * 인덱스 통한 레코드 1건 읽는게, 직접 레코드 읽는 것 보다 4~5배 많은 것으로 예측함
  * 인덱스를 통해 읽어야 할 레코드 건수(옵티마이저가 판단한 예상 건수)가 레코드 20~25% 넘어가면 인덱스 이용하지 않고 풀스캔해서 필터링하는 방식으로 가져오는게 효율적
* 결론 : 많은 건수 레코드 읽을 땐 인덱스 이점이 없다~

### 8.3.4 B-Tree 인덱스 통한 데이터 읽기
인덱스 레인지 스캔

<img width="477" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/09f246ef-9d29-4ddd-855b-178351eb4a59">

* 인덱스 풀스캔보다는 빠른 방법
  * 이번 절에서는 한 건만 읽는 경우/여러 건 읽는 경우 묶어서 인덱스 레인지 스캔으로 표현....
* 검색해야 할 인덱스 범위가 결정되었을 때 사용하는 방식
* 시작 위치만 찾으면 마지막 지점까지 리프노드만 레코드 순으로 읽으면 됨
* 리프노드에 저장된 레코드 주소로 데이터 파일 레코드 읽는 과정에서 한건한건 단위로 랜덤IO가 발생함
* 인덱스 레인지 스캔 과정
  1. index seek(인덱스 탐색) : 인덱스 에서 조건 만족하는 값이 저장된 위치를 찾음
  2. index scan(인덱스 스캔) : 1번에서 찾은 위치부터 필요한 만큼 인덱스를 쭉 읽음
  3. 2번에서 읽은 인덱스 키/레코드 주소를 통해 데이터 레코드 페이지 가져오고 최종 레코드 읽어옴 (커버링 인덱스는 이 과정 생략)
* `SHOW STATUS LIKE 'Handler_%';` 명령으로 인덱스 탐색/스캔 단계 작업이 얼마나 수행되었는지 확인 가능
  * `Handler_read_key` : 인덱스 탐색 실행 개수
  * `Handler_read_next`, `Hander_read_prev` : 인덱스 스캔 실행 개수(next: 정순, prev: 역순)
  * `Hadner_read_first`, `Hander_read_last` : 인덱스 첫번째 레코드, 마지막 레코드 읽은 횟수

인덱스 풀스캔
* 인덱스의 처음부터 끝까지 모두 읽는 방식
* 쿼리 조건절의 컬럼이 인덱스 첫 컬럼이 아닌 경우 풀스캔 사용...
  * ex) (A,B,C) 로 생성된 인덱스에서 조건을 B나 C로 사용한 경우
* 일반적으로 인덱스 크기가 테이블 크기보다는 작으므로 테이블 풀스캔보다는 인덱스 풀스캔이 효율적이라, 쿼리가 인덱스에 명시된 컬럼만으로 조건 처리할 수 있을 때 이 방식 사용함
  * 인덱스 뿐만 아니라 데이터 레코드까지 읽어야 하면 이 방식 사용하지 않음
* 인덱스 레인지 스캔보다는 느리지만 테이블 풀스캔보다는 효율적..

루스(Loose) 인덱스 스캔

<img width="331" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/ebfb1b80-a7d6-4c73-a66e-7bda8d856b27">

* 느슨하게 듬성듬성 읽는 것. 인덱스 레인지 스캔, 인덱스 풀스캔은 타이트(Tight) 인덱스 스캔으로 분류됨
* 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(Skip)하고 넝머감
* `GROUP BY` 나 `MAX()` `MIN()` 등의 함수에서 최적화 할 때 사용
* 여러 제약조건이 있음..(10장 실행계획에서~)


인덱스 스킵 스캔
```sql
ALTER TABLE employess
ADD INDEX ix_gender_birthdate(gender, birth_date);

-- // a) 인덱스 사용 불가
SELECT * FROM employess WHERE birth_date >= '1965-02-01';

-- // b) 인덱스 사용 가능
SELECT * FROM employess WHERE gender='M' AND birth_date >= '1965-02-01';
```
* 인덱스는 컬럼 순서가 매우매우매우 중요함...
* 8.0 버전부터는 a) 상황에서도 gender 컬럼 건너뛰고 인덱스 검색 가능하도록 인덱스 스킵 스캔 최적화 도입

<img width="353" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/4ed49db0-577f-48a4-ae2f-6b70b5317302">

* 옵티마이저가 gender 컬럼에서 유니크한 값을 모두 조회해 **주어진 쿼리에 gender 조건 추가해서 쿼리 다시 실행**하는 형태로 처리함
* 인덱스 스킵 스캔 단점
  * WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  * 커버링 인덱스 여야 함 -> 커버링 인덱스 아니면 풀스캔으로 실행계획 수립됨...


## 질문
* InnoDB에서 UK 속성의 인덱스는 쓰기 성능이 많이 느릴까?(=MyISAM과 유사할까)
* 커버링 인덱스 처리 가능한 경우만 인덱스 풀스캔이 효율적이라는 뜻인지