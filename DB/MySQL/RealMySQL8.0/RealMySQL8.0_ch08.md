# RealMySQL8.0 ch08. 인덱스

## 8.1 디스크 읽기 방식
랜덤IO, 순차(Sequential)IO 와 같은 디스크 읽기 방식은 인덱스와 연관이 있다~
DB 성능 튜닝은 DiskIO를 줄이느냐가 관건일 때가 상당히 많다.

### 8.1.1 HDD와 SSD
* SSD(Solid State Drive) : 기계식 HDD를 대체하기 위한 전자식 저장 매체. 기존 HDD와 같은 인터페이스(SATA, SAS)를 지원하므로 DAS나 SAN에 그대로 사용 가능
  * 기존 HDD에서 데이터 저장용 플래터(원판)를 제거하고 플래시 메모리를 장착 => 원판이 없어져 매우 빠르게 데이터 릭고 쓸 수 있음
  * D-RAM보다는 느리지만 HDD보다는 훨씬 빠르다
  * HDD보다 용량이 적고 비싸지만 전보다는 대중화되어 DBMS용으로 많이 사용함
* 헤더를 움직이지 않고 한 번에 많은 데이터 읽는 순차IO에서는 HDD가 조금 빠르거나 같다.
* 랜덤IO는 SSD가 훠어어얼씬 빠르다
* 일반적인 웹서비스(OLPT)환경에서는 SSD가 HDD보다 훨씬빠르다

### 8.1.2 랜덤IO와 순차IO
* 랜덤IO : HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 헤더를 이동시켜 읽는 것
  * 랜덤 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 3번 움직임
* 순차IO : 과정은 랜덤과 같지만, 헤더 이동시키는 정도가 다름...
  * 순차 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 1번 움직임

=> 여러 번 읽기/쓰기를 요청하는 랜덤IO작업 부하가 크다. 그런데 DB 대부분은 랜덤IO가 일어나므로, MySQL서버에서 자체적으로 바이너리 로그 버퍼나, InnoDB버퍼 등 기능이 내장됨.
* SSD은 랜덤/순차 차이가 거의 없어도 결국 전체 throughput이 떨어짐
  * throughput: 단위시간당 데이터 전송 처리량
* 쿼리를 튜닝해서 랜덤IO를 순차IO로 바꿔서 실행할 수 없음.. 쿼리 튜닝 자체가 랜덤IO 자체를 줄이는 것 = 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는것
  * 그~래도 대체적으로 인덱스 레인지 스캔은 랜덤IO를 사용하고 풀스캔은 순차IO를 사용함. 큰 테이블 대부분 데이터를 읽는 작업은 풀스캔을 유도하도록 하는데, 순차IO가 랜덤IO보다 빨리 많은 레코드를 읽게 함(=OLTP보다는 데이터 웨어하우스나 통계작업 등에서 사용되는 쿼리...)

## 8.2 인덱스란?
* 컬럼(들)의 값과, 레코드 주소를 key-value 형태로 저장한 형태
* 컬럼(들) 값을 미리 주어진 형태로 정렬되어 저장
* 자료구조로 비유
  * Sorted List : 인덱스 = insert는 느리고 find는 빠름
  * Array List : 데이터파일 = find는 느리고 insert는 빠름
* 인덱스 = 저장(INSERT, UPDATE, DELETE) 성능 희생하고 SELECT 속도 높이는 기능

인덱스의 구분
* Primary Key(PK, 식별자): NULL과 중복을 허용하지 않음. 해당 레코드를 식별할 수 있는 기준값.
* Secondary Index(Secondary Key, 보조키): PK를 제외한 모든 인덱스. UK(유니크 인덱스)는 PK와 성격이 비슷해서 대체키라고 하기도 함.

인덱스 저장 방식(알고리즘)별 구분
* B-Tree : 일반적인 인덱싱 알고리즘. 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱 하는 방법
* Hash : 컬럼을 해싱해서 인덱싱하는 방법. Prefix와 같이 일부 검색하거나 범위 검색(레인지 스캔)할 때는 해시 인덱스가 사용되지 않는다. Redis와 같은 메모리 기반 DB에서 많이 사용함
  * Redis 디폴트가 Hash로 알고있음... 따라서 키를 검색할 때 Prefix 검색( `keyword*` )을 하면 어어어엄청 성능 떨어지는 것으로 인지하고 있다.
* 그 외 기타등등..(R-Tree, Fractal-Tree, Merge-Tree 등)

## 8.3 B-Tree 인덱스
인덱싱 알고리즘 중 가장 많이 사용되고 가장 먼저 도입되었고, 가장 범용적으로 사용되고 있는 알고리즘. 원래 값을 변형하지 않고 항상 정렬된 상태로 유지하는 알고리즘. 
B-Tree의 B는 Binary가 아니라 **Balanced** 이다.

### 8.3.1 구조 및 특성
<img width="558" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/fdc41a32-0bfc-4b67-a611-07ca806b06a3">

* 트리 최상위에 하나의 Root node 존재, 하위에 자식노드들 붙은 형태. 최하위에 있는 노드는 Leaf Node, 중간 노드는 Branch Node라 함.
* Leaf Node에는 항상 **실제 데이터 레코드 주소** 를 가지고 있음
* 인덱스 키 값은 모두 정렬되어 있지만 데이터 파일 레코드 임의의 순서로 저장되어 있음(삭제된 공간 재활용 하기 때문에 꼭 순서대로 저장되는것도 아님...)

InnoDB vs MyISAM
* MyISAM : 레코드 주소로 ROWID를 저장.
  * 세컨더리 인덱스를 생성하면 ROWID를 기준으로 찾기 때문에 데이터의 물리적인 주소를 저장함
* InnoDB : PK가 ROWID역할을 함.
  * 세컨더리 인덱스를 생성하면 PK를 저장하기 때문에 논리적인 주소를 저장함
  * 논리적인 주소(PK)를 갖기 때문에, 인덱스를 통한 읽기에서 레코드를 바로 찾지 못하고 PK를 통해 B-Tree를 한번 더 탄다.
* => InnoDB가 성능 떨어지는거 아니야? = 아님... 8.8 클러스터링 인덱스에서 추가 설명

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
인덱스 키 추가

인덱스 키 삭제

인덱스 키 변경

인덱스 키 검색

## 질문
