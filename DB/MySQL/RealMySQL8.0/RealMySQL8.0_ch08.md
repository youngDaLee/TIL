# RealMySQL8.0 ch08. 인덱스

## 8.1 디스크 읽기 방식
랜덤IO, 순차(Sequential)IO 와 같은 디스크 읽기 방식은 인덱스와 연관이 있다~
DB 성능 튜닝은 DiskIO를 줄이느냐가 관건일 때가 상당히 많다.

### 8.1.1 HDD와 SSD
* SSD(Solid State Drive) : 기계식 HDD를 대체하기 위한 전자식 저장 매체. 기존 HDD와 같은 인터페이스(SATA, SAS)를 지원하므로 DAS나 SAN에 그대로 사용 가능
  * 기존 HDD에서 데이터 저장용 플래터(원판)를 제거하고 플래시 메모리를 장착 => 원판이 없어져 매우 빠르게 데이터 릭고 쓸 수 있음
  * D-RAM보다는 느리지만 HDD보다는 훨씬 빠르다
  * HDD보다 용량이 적고 비싸지만 전보다는 대중화되어 DBMS용으로 많이 사용함
* 헤더를 움직이지 않고 한 번에 많은 데이터 읽는 순차IO에서는 HDD가 조금 빠르거나 같다.
* 랜덤IO는 SSD가 훠어어얼씬 빠르다
* 일반적인 웹서비스(OLPT)환경에서는 SSD가 HDD보다 훨씬빠르다

### 8.1.2 랜덤IO와 순차IO
* 랜덤IO : HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 헤더를 이동시켜 읽는 것
  * 랜덤 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 3번 움직임
* 순차IO : 과정은 랜덤과 같지만, 헤더 이동시키는 정도가 다름...
  * 순차 IO는 3개 페이지의 데이터를 읽기 위해 헤더를 1번 움직임

=> 여러 번 읽기/쓰기를 요청하는 랜덤IO작업 부하가 크다. 그런데 DB 대부분은 랜덤IO가 일어나므로, MySQL서버에서 자체적으로 바이너리 로그 버퍼나, InnoDB버퍼 등 기능이 내장됨.
* SSD은 랜덤/순차 차이가 거의 없어도 결국 전체 throughput이 떨어짐
  * throughput: 단위시간당 데이터 전송 처리량
* 쿼리를 튜닝해서 랜덤IO를 순차IO로 바꿔서 실행할 수 없음.. 쿼리 튜닝 자체가 랜덤IO 자체를 줄이는 것 = 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 개선하는것
  * 그~래도 대체적으로 인덱스 레인지 스캔은 랜덤IO를 사용하고 풀스캔은 순차IO를 사용함. 큰 테이블 대부분 데이터를 읽는 작업은 풀스캔을 유도하도록 하는데, 순차IO가 랜덤IO보다 빨리 많은 레코드를 읽게 함(=OLTP보다는 데이터 웨어하우스나 통계작업 등에서 사용되는 쿼리...)

## 8.2 인덱스란?
* 컬럼(들)의 값과, 레코드 주소를 key-value 형태로 저장한 형태
* 컬럼(들) 값을 미리 주어진 형태로 정렬되어 저장
* 자료구조로 비유
  * Sorted List : 인덱스 = insert는 느리고 find는 빠름
  * Array List : 데이터파일 = find는 느리고 insert는 빠름
* 인덱스 = 저장(INSERT, UPDATE, DELETE) 성능 희생하고 SELECT 속도 높이는 기능

인덱스의 구분
* Primary Key(PK, 식별자): NULL과 중복을 허용하지 않음. 해당 레코드를 식별할 수 있는 기준값.
* Secondary Index(Secondary Key, 보조키): PK를 제외한 모든 인덱스. UK(유니크 인덱스)는 PK와 성격이 비슷해서 대체키라고 하기도 함.

인덱스 저장 방식(알고리즘)별 구분
* B-Tree : 일반적인 인덱싱 알고리즘. 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱 하는 방법
* Hash : 컬럼을 해싱해서 인덱싱하는 방법. Prefix와 같이 일부 검색하거나 범위 검색(레인지 스캔)할 때는 해시 인덱스가 사용되지 않는다. Redis와 같은 메모리 기반 DB에서 많이 사용함
  * Redis 디폴트가 Hash로 알고있음... 따라서 키를 검색할 때 Prefix 검색( `keyword*` )을 하면 어어어엄청 성능 떨어지는 것으로 인지하고 있다.
* 그 외 기타등등..(R-Tree, Fractal-Tree, Merge-Tree 등)

## 8.3 B-Tree 인덱스
인덱싱 알고리즘 중 가장 많이 사용되고 가장 먼저 도입되었고, 가장 범용적으로 사용되고 있는 알고리즘. 원래 값을 변형하지 않고 항상 정렬된 상태로 유지하는 알고리즘. 
B-Tree의 B는 Binary가 아니라 **Balanced** 이다.

### 8.3.1 구조 및 특성
<img width="558" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/fdc41a32-0bfc-4b67-a611-07ca806b06a3">

* 트리 최상위에 하나의 Root node 존재, 하위에 자식노드들 붙은 형태. 최하위에 있는 노드는 Leaf Node, 중간 노드는 Branch Node라 함.
* Leaf Node에는 항상 **실제 데이터 레코드 주소** 를 가지고 있음
* 인덱스 키 값은 모두 정렬되어 있지만 데이터 파일 레코드 임의의 순서로 저장되어 있음(삭제된 공간 재활용 하기 때문에 꼭 순서대로 저장되는것도 아님...)

InnoDB vs MyISAM
* MyISAM : 레코드 주소로 ROWID를 저장.
  * 세컨더리 인덱스를 생성하면 ROWID를 기준으로 찾기 때문에 데이터의 물리적인 주소를 저장함
* InnoDB : PK가 ROWID역할을 함.
  * 세컨더리 인덱스를 생성하면 PK를 저장하기 때문에 논리적인 주소를 저장함
  * 논리적인 주소(PK)를 갖기 때문에, 인덱스를 통한 읽기에서 레코드를 바로 찾지 못하고 PK를 통해 B-Tree를 한번 더 탄다.
* => InnoDB가 성능 떨어지는거 아니야? = 아님... 8.8 클러스터링 인덱스에서 추가 설명

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제
인덱스 키 추가
* 스토리지 엔진에 따라 즉시 인덱스에 저장 될 수도 있고, 아닐수도 있음
* 저장될 키값을 이용해 B-Tree상 적절한 위치를 검색
* 저장될 위치 결정되면 대상 레코드 주소 정보를 B-Tree 리프노드상에 저장
* 리프노드가 꽉 차면 리프노드 분리(split) => 이런 작업 때문에 쓰기작업에 비용 많이 드는걸로 알려짐...
* INSERT, UPDATE 성능 변화 정확히 예측하려면 컬럼 수, 컬럼 크기, 컬럼 특성등을 고려해야하지만..
  * 대략적으로는 레코드를 추가하는 작업 비용을 1이라 할 때, 인덱스 추가하는 작업을 1.5 정도로 예측함.
  * 인덱스 하나도 없는 경우 작업 비용 1
  * 인덱스 3개가 있는 경우는 5.5(1.5*3 + 1)정도 비용이 드는 것으로 예측
  * => 비용 대부분이 메모리/CPU가 아닌 디스크로부터 인덱스 페이지 읽고쓰기 하는데 걸리는 시간
* MyISAM, MEMORY : INSERT 실행 즉시 B-Tree 값 변경
* InnoDB : 인덱스 키 추가 작업 지연처리...(PK, UK는 중복체크 필요해서 즉시 처리) => 4.2.10 참고

인덱스 키 삭제
* B-Tree 리프노드 찾아서 삭제 마크만 하면 작업 완료
* 삭제 마킹된 공간은 방치되거나 재사용됨.
* 삭제 마킹 작업이 필요하므로 diskIO 필요한 작업...
* InnoDB에서는 INSERT/UPDATE와 같이 버퍼링 처리(지연 처리) 가능
* MyISAM, MEMORY는 체인지버퍼 같은 기능이 없어서 디스크 작업 완료된 후에 쿼리 실행 완료됨

인덱스 키 변경
* B-Tree 키값이 변경되는 경우에는 단순 인덱스상 키값만 변경하는게 불가능...
  * 키값 삭제하고 새로운 키값 추가하는 형태로 처리됨
* 추가/삭제와 마찬가지로 InnoDB는 버퍼링 가능, 나머지는 불가...

인덱스 키 검색
* 쓰기(추가,삭제,변경) 비용 감당하면서 인덱스를 쓰는 이유...
* B-Tree 루트노드부터 브랜치노드를 거쳐 최종 리프노드까지 이동하며 비교작업 수행 = 트리탐색
* B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우 사용
* 인덱스 값에 변형이 가해진 경우는 B-Tree 인덱스 사용 불가
* InnoDB에서의 인덱스...
  * 레코드 잠금, 갭락이 검색 수행 후 검색한 인덱스 잠그고 테이블 레코드 잠그는 방식으로 구현됨
  * 따라서 UPDATE, DELETE 수행 후 테이블에서 사용할 수 있는 인덱스 없으면 불필요하게 많은 인덱스를 잠금
  * 내가 이해한 것 : 레코드 잠금과 갭락이 update/delete 할 때 작업을 위해 읽은 레코드를 모두 잠그므로, 읽는 레코드 수를 줄여야 하기 때문에 인덱스가 필요함

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스 키 값의 크기
* Page(Block)
  * InnoDB에서 디스크에 데이터를 저장하는 가장 기본 단위.
  * 디스크 읽기쓰기의 최소 작업 단위. InnoDB 버퍼풀에서 데이터 버퍼링하는 기본 단위.
  * 리프노드를 구분한 기준
* B-Tree는 자식노드 개수가 가변적(이진트리 아님!!!)
* B-Tree의 자식노드 수 : 인덱스 페이지 크기와 키값 크기에 따라 결정됨
  * `innodb_page_size` 를 통해 4KB ~ 64KB 선택(디폴트 16KB)
  * a) page_size 16KB인 인덱스에서, 인덱스 키가 16바이트, 자식노드 주소가 12바이트라면 하나의 인덱스 페이지(16KB)에 자식노드 수 585개(16*1024/(16+12)) 가질 수 있는 B-Tree
  * b) page_size 16KB인 인덱스에서, 인덱스 키가 32바이트, 자식노드 주소가 12바이트라면 하나의 인덱스 페이지(16KB)에 자식노드 수 372개(16*1024/(32+12)) 가질 수 있는 B-Tree
  * SELECT 쿼리가 500개 레코드 읽어야 할 때 a)는 한 개의 페이지로 해결 될 수 있지만, b)는 최소 2번 이상 읽어야 함 => 디스크로부터 읽는 개수 늘어나고, 그만큼 느려짐
  * 인덱스 크기가 커지면 버퍼풀에 저장할 수 있는 레코드가 적어짐. => 메모리 효율 떨어짐

B-Tree 깊이
* B-Tree Depth는 중요하지만 제어할 수 있는 방법이 없음
* B-Tree 깊이가 3인 경우 키값이 16바이트면 약 2억개(585 * 585 * 585), 32바이트면 약 5천만개(372 * 372 * 372).
* B-Tree 깊이 = 값 검색할 때 몇 번이나 랜덤하게 디스크 읽어야 하는지
* 인덱스 키 값 커질수록 하나의 페이지가 담을 수 있는 키 값 개수 적어지고, 같은 레코드 건수더라도 B-Tree 깊이가 깊어져 더 많은 디스크 읽기가필요
* 결론 : 인덱스 크기 작게 만들자~

선택도(기수성)
* 선택도(selectivity) = 기수성(cardinailty) 인덱스에서 거의 같은 의미로 사용됨.
* 인덱스 키 값 가운데 유니크한 값의 수. 키값 중 중복된 값이 많으면 기수성/선택도가 떨어짐
* 선택도(기수성)이 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리됨

읽어야 하는 레코드 건수
* 인덱스를 통해레코드 읽는 건, 인덱스 거치지 않고 읽는 것 보다 높은 비용이 든다.
* 인덱스를 이용한 읽기의 손익분기점
  * 인덱스 통한 레코드 1건 읽는게, 직접 레코드 읽는 것 보다 4~5배 많은 것으로 예측함
  * 인덱스를 통해 읽어야 할 레코드 건수(옵티마이저가 판단한 예상 건수)가 레코드 20~25% 넘어가면 인덱스 이용하지 않고 풀스캔해서 필터링하는 방식으로 가져오는게 효율적
* 결론 : 많은 건수 레코드 읽을 땐 인덱스 이점이 없다~

### 8.3.4 B-Tree 인덱스 통한 데이터 읽기
인덱스 레인지 스캔

<img width="477" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/09f246ef-9d29-4ddd-855b-178351eb4a59">

* 인덱스 풀스캔보다는 빠른 방법
  * 이번 절에서는 한 건만 읽는 경우/여러 건 읽는 경우 묶어서 인덱스 레인지 스캔으로 표현....
* 검색해야 할 인덱스 범위가 결정되었을 때 사용하는 방식
* 시작 위치만 찾으면 마지막 지점까지 리프노드만 레코드 순으로 읽으면 됨
* 리프노드에 저장된 레코드 주소로 데이터 파일 레코드 읽는 과정에서 한건한건 단위로 랜덤IO가 발생함
* 인덱스 레인지 스캔 과정
  1. index seek(인덱스 탐색) : 인덱스 에서 조건 만족하는 값이 저장된 위치를 찾음
  2. index scan(인덱스 스캔) : 1번에서 찾은 위치부터 필요한 만큼 인덱스를 쭉 읽음
  3. 2번에서 읽은 인덱스 키/레코드 주소를 통해 데이터 레코드 페이지 가져오고 최종 레코드 읽어옴 (커버링 인덱스는 이 과정 생략)
* `SHOW STATUS LIKE 'Handler_%';` 명령으로 인덱스 탐색/스캔 단계 작업이 얼마나 수행되었는지 확인 가능
  * `Handler_read_key` : 인덱스 탐색 실행 개수
  * `Handler_read_next`, `Hander_read_prev` : 인덱스 스캔 실행 개수(next: 정순, prev: 역순)
  * `Hadner_read_first`, `Hander_read_last` : 인덱스 첫번째 레코드, 마지막 레코드 읽은 횟수

인덱스 풀스캔
* 인덱스의 처음부터 끝까지 모두 읽는 방식
* 쿼리 조건절의 컬럼이 인덱스 첫 컬럼이 아닌 경우 풀스캔 사용...
  * ex) (A,B,C) 로 생성된 인덱스에서 조건을 B나 C로 사용한 경우
* 일반적으로 인덱스 크기가 테이블 크기보다는 작으므로 테이블 풀스캔보다는 인덱스 풀스캔이 효율적이라, 쿼리가 인덱스에 명시된 컬럼만으로 조건 처리할 수 있을 때 이 방식 사용함
  * 인덱스 뿐만 아니라 데이터 레코드까지 읽어야 하면 이 방식 사용하지 않음
* 인덱스 레인지 스캔보다는 느리지만 테이블 풀스캔보다는 효율적..

루스(Loose) 인덱스 스캔

<img width="331" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/ebfb1b80-a7d6-4c73-a66e-7bda8d856b27">

* 느슨하게 듬성듬성 읽는 것. 인덱스 레인지 스캔, 인덱스 풀스캔은 타이트(Tight) 인덱스 스캔으로 분류됨
* 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(Skip)하고 넝머감
* `GROUP BY` 나 `MAX()` `MIN()` 등의 함수에서 최적화 할 때 사용
* 여러 제약조건이 있음..(10장 실행계획에서~)


인덱스 스킵 스캔
```sql
ALTER TABLE employess
ADD INDEX ix_gender_birthdate(gender, birth_date);

-- // a) 인덱스 사용 불가
SELECT * FROM employess WHERE birth_date >= '1965-02-01';

-- // b) 인덱스 사용 가능
SELECT * FROM employess WHERE gender='M' AND birth_date >= '1965-02-01';
```
* 인덱스는 컬럼 순서가 매우매우매우 중요함...
* 8.0 버전부터는 a) 상황에서도 gender 컬럼 건너뛰고 인덱스 검색 가능하도록 인덱스 스킵 스캔 최적화 도입

<img width="353" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/4ed49db0-577f-48a4-ae2f-6b70b5317302">

* 옵티마이저가 gender 컬럼에서 유니크한 값을 모두 조회해 **주어진 쿼리에 gender 조건 추가해서 쿼리 다시 실행**하는 형태로 처리함
* 인덱스 스킵 스캔 단점
  * WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  * 커버링 인덱스 여야 함 -> 커버링 인덱스 아니면 풀스캔으로 실행계획 수립됨...

### 8.3.5 Multi-column(다중컬럼) 인덱스
<img width="286" alt="image" src="https://github.com/youngDaLee/TIL/assets/64643665/05ee6245-d1ae-4722-80ea-db37cdbac7dc">

* 두 번째 컬럼은 첫 번째 커럼에 의존해서 정렬되어 있다.


### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
인덱스가 오름차순 정렬되었다고 해서 오름차순으로만 읽지는 않음. 옵티마이저가 실시간으로 만들어주는 실행계획에 따라 인덱스 스캔 방향을 결정함

#### 8.3.6.1 인덱스의 정렬
* MySQL 5.7 까지는 컬럼 단위 정렬 순서를 혼합해서 생성할 수 었었으나, 8.0 부터는 혼합해서 사용 가능함
```sql
CREATE INDEX ix_tname_tuser ON employees (tname ASC, tuser DESC);
```

인덱스 스캔 방향
* 생성 시점에 오름차순/내림차순으로 저장된 것과 별개로, 옵티마이저가 효율적으로 읽기 방향을 전환하여 실행계획을 만든 
* 다만 내림차순으로 저장된 데이터를 다시 오름차순으로 읽으려고 할 때(인덱스 역순으로 읽고자 할 때) 약 28% 정도 성능이 느린 것을 확인할 수 있다.
* 따라서 자중 사용되는 정렬 순서대로 인덱스를 생성하는것이 중요하다.

#### 8.3.7 B-Tree 인덱스 가용성과 효율성
어떤 상황에서 인덱스를 사용하는지 식별할 수 있어야 함.

#### 8.3.7.1 비교 조건 종류와 효율성
컬럼 사용 저건이 동등비교나 범위조건인지에 따라 인덱스 활용 형태가 달라짐
```sql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10;

-- CASE A)
CREATE INDEX (dept_no, emp_no) ON dept_emp;

-- CASE B)
CREATE INDEX (emp_no, dept_no) ON dept_emp;
```

- CASE A) `dept_no='d002'`, `emp_no>=10` 인 레코드 찾은 뒤, 쭉 읽으면 됨
- CASE B) 우선  `emp_no>=10 AND dept_no='d002'` 인 레코드를 찾고, 그 이후 모든 레코드에 대해 `dept_no='d002'` 레코드 찾는 과정 거침

A가 훨씬 효율적

#### 8.3.7.2 인덱스의 가용성
B-Tree인덱스의 특징 : Left-most 정렬....

#### 8.3.7.3 가용성과 효율성 판단
```sql
INDEX ix_test (col1, col2, ... coln)
```

인덱스를 사용할 수 없는 경우

* NOT-EQUAL 로 비교된 경우
* LIKE '%??'(뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
* 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교된 경우
* NOt-DETERMINSTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
* 데이터 타입이 서로 다른 비교(인덱스 컬럼의 다른 타입을 변환해야 비교가 가능한 경우)
* col1에 대한 조건이 없는 경우

## 8.4 R-Tree 인덱스
GPC, 지도 서비스와 같은 위치 기반 서비스를 구현하는 방법 => MySQL의 Spatical Extension(공간 확장)

MySQL의 공간 확장
* 공간 데이터를 저장할 수 있는 데이터 타입
* 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 인덱스)
* 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 8.4.1 구조 및 특성
POINT, LINE, POLYGON, GEOMETRY(POINT, LINE, POLYGON의 슈퍼타입)
* MBR : Minimum Bounding Rectangle... 해당 도형을 감싸는 최소 크기의 사각형
* MBR 포함 관계를 B-Tree로 구현한게 R-Tre

### 8.4.2 R-Tree 용도
* 포함관계를 기반으로 만든 인덱스...
* `ST_Contains()`, `ST_Within()` 과 같이 포함관계를 비교하는 함수로 검색 사용하는 경우에 사용...

## 8.5 전문 검색 인덱스
### 8.5.1 인덱스 알고리즘
사용자가 검색해낼 키워드를 분석해내고, 빠른 검색용으로 사용 할 수 있도록 인덱스를 구축함

#### 어근 분석 알고리즘
MySQL 서버 인덱스는 아래 두 과정을 거침
* 불용어(Stop-Word) 처리
  * 가치 없는 단어 필터링해서 제거
* 어근 분석(Stemming)
  * 선정된 단어 원형을 찾는 작업
  * MeCab을 플러그인 형태로 사ㅛㅇ할 수 있도록 지원...

#### n-gram 알고리즘
MeCab 은 범용적 사용이 어려움... => 단점 보완한 방법 : n-gram
* 띄어쓰기로 구분된 단어를 n개 글자 단위로 쪼갬

#### 불용어 변경 및 삭제

### 8.5.2 전문 검색인덱스의 가용성
* 쿼리 문장이 전문검색을 위한 문법(`MATCH ... AGAINST ...`) 을 사용
* 테이블이 전문검색 대상 컬럼에 대해 전문 인덱스 보유


## 8.6 함수 기반 인덱스
* 가상 컬럼을 이용한 인덱스
* 함수를 이용한 인덱스

MySQL 함수 기반 인덱스는 인덱싱할 값 계산하는 과정 차이만 있을 뿐, 실제 인덱스 내부 구조 및 유지관리 기법은 B-Tree와 동일함

### 8.6.1 가상 컬럼 이용한 인덱스
```sql
CREATE TABLE user (
    uid BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (uid)
);
```
* `first_name` + `last_name` 검색해야 하는 요건이 생겼을 때....
  * 8.0 이전 버전은 `full_name` 컬럼을 새로 만들어야 했음
  * 8.0 부터 가상 컬럼 추가 가능
```sql
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ',last_name)) VIRTUAL,
ADD INDEX ix_fullname (full_name);
```

### 8.6.2 함수를 이용한 인덱스
가상컬럼은 5.7에서도 사용할 수 있엇지만, 함수를 직접 인덱스 생성 구문에 사용은 불가했음....


8.0 부터 아래처럼 테이블 구조 변경하지 않고 함수 직접 사용하는 인덱스 사용 가능
```sql
CREATE TABLE user (
    uid BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (uid),
    INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
);
```

## 8.7 멀티 밸류 인덱스
JSON 타입 지원하며, JSON 배열 타입에 저장된 원소에 대한 인덱스 요건이 발생
* JSON 포맷 데이터인 MongoDB는 처음부터 제공하던 서비스..
* MySQL 8.0이 되면서 부족함이 없어졌다~

```sql
CREATE TABLE user (
    uid BIGINT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    create_info JSON,
    INDEX my_creditscores ( (CAST(create_info -> '$.credit_scores' AS UNSIGNED ARRAY)))
)
```

## 8.8 클러스터링 인덱스
레코드를 비슷한 것 끼리 묶어 저장하는 형태로 구현하는 것... InnoDB에서만 지원하고 나머지에서는 지원하지 않음

### 8.8.1 클러스터링 인덱스
* PK에 대해서만 적용되는 내용
* PK값이 비슷한 레코드끼리 묶어서 저장하는 것
* PK값에 의해 레코드 물리적인 값이 결정됨
* 클러스터링 테이블은 PK의존도가 크기 때문에 신중하게 PK를 결정하자~
* 인덱싱이라기보다는 테이블 레코드 저장방식.....
* InnoDB 같은 클러스터링 인덱스 기반 엔진은 **PK 기반 검색이 매우 빠름**
* 대신 **레코드 저장, PK 변경** 이 상대적으로 느림
  * 클러스터링 키가 아닌 테이블(MyISAM 같은..)은 인덱스가 변경된다고 해서 실제 데이터 레코드 저장 위치가 변경되지는 않음

PK가 없는 InnoDB 테이블이 클러스터링 테이블로 구성되는 방법
1. PK가 있으면 PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가하는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택

가능하면 PK를 명시적으로 생성하자~~

### 8.8.2 세컨더리 인덱스에 미치는 영향
* PK가 변경될 때 마다 데이터 레코드 주소가 변경되기 때문에 테이블 모든 인덱스의 주솟값을 변경해야 함...
* 이런 문제 때문에 레코드 실제 저장 주소가 아니라 세컨더리 인덱스는 **PK값을 저장함**

MyISAM vs InnoDB 인덱싱된 데이터 스캔하는 방법
* MyISAM : 인덱스 검색해서 레코드 주소 확인하고, 레코드 주소 이용해 최종 레코드 가져옴
* InnoDB : 인덱스 검색해서 레코드 PK 확인하고, PK 인덱스 검색해서 최종 레코드 가져옴

대신에 pK 성능이 InnoDB가 아아아주 좋으니까 성능 저하에대해 크게 걱정하지 않아도 됨..

### 8.8.3 클러스터링 인덱스 장단점
* 장점
  * PK 처리성능이 아주 빠름
  * 테이블 모든 세컨더리가 PK를 가지고 있기 때문에 커버링 인덱스로 처리될 수 있는 경우가 많음
* 단점
  * 테이블 세컨더리 인덱스가 PK를 갖기 때문에, PK가 클 경우 전체적으로 인덱스 크기가 커짐
  * 세컨더리를 통해 검색할 때 PK를 다시 검색해야 하기 때문에 느림
  * INSERT 할 때 PK에 의해 저장 위치를 결정해야 하기 때문에 느림
  * PK 변경 시, 레코드 DELETE/INSERT 하는 작업 필요하기 때문에 느림

### 8.8.4 클러스터링 테이블 사용 시 주의사항
* PK 크기
  * 크면 다른 테이블에 비해 더 크기 커짐...
* PK는 AUTO-INCREMENT보다 업무적인 컬럼으로 생성(가능하면)
  * PK로 검색했을때의 이점이 아아아주 큰 테이블...
  * 아무리 PK가 커지더라도 빈번하게 검색되는 키를 PK로 설정하는게 아주 중요
* PK 반드시 명시
  * 얘 장점이니까
* AUTO-INCREMENT를 인조 식별자로 사용할 경우
  * 세컨더리 인덱스도 필요하고 PK도 길다면 그냥 AUTO-INCREMENT로 인조식별자 쓰는게 나음
  * 로그테이블같이 조회보다는 INSERT 위주 테이블은 AUTO-INCREMENT 쓰는게 성능에 좋음


## 8.9 유니크 인덱스
인덱스 보다는 제약조건....
* 같은 값이 2개 이상 저장될 수 없는 인덱스
* NULL은 특정 값이 아니기 때문에 2개 이상 저장 가능

### 8.9.1 유니크 인덱스 vs 일반 세컨더리 인덱스
read
* 유니크하지 않은 인덱스는 읽어야 할 레코드 건수가 많아서 느린거지, 유니크가 아니라서 느린게 아님
* 읽어야 할 레코드 건수 같으면 성능상 차이는 미미함

write
* 유니크 인덱스는 중복 체크 과정이 들어감.
* 일반 세컨더리보다 유니크가 느림

### 8.9.2 유니크 인덱스 상요 주의샇아
* 꼭 필요하면 유니크하게 생성...
* 더 성능이 좋아질 것 같으면 불필요하게 유니크 인덱스로 생성할 필요가 없음
* 유니크 인덱스도 결국 세컨더리 인덱스이므로, 유니크 인덱스 생성했으면 따로 인덱스 생성 안해도 됨

## 8.10 외래키
InnoDB에서만 생성 가능.    
외래키 제약이 설정되면 자동으로 연관되는 테이블 컬럼에 인덱스까지 생성됨. 외래키 제거되지 않으면 생성된 인덱스 삭제할 수 없음.


InnoDB 외래키의 중요한 특성
* 테이블 변경(쓰기잠금) 발생하는 경우만 잠금 경합(잠금 대기) 발생
* 외래키와 연관되지 않은 컬럼 변경은 최대한 잠금 경합(잠금 대기) 발생시키지 ㅇ낳음



## 질문
* InnoDB에서 UK 속성의 인덱스는 쓰기 성능이 많이 느릴까?(=MyISAM과 유사할까)
* 커버링 인덱스 처리 가능한 경우만 인덱스 풀스캔이 효율적이라는 뜻인지