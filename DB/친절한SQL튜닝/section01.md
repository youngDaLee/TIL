# 1장. SQL 처리 과정과 I/O
## 1.1 SQL 파싱과 최적화
* 결과 집합을 구조적, 집합적으로 만드는 질의언어 SQL -> SQL 결과 집합을 절차적으로 만들어 주는 애가 옵티마이저 = 옵티마이저가 프로그래밍을 대신해준다~
* DBMS내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 모든 과정 = SQL 최적화

SQL 최적화
1. SQL 파싱
   * 파싱트리 생성(SQL 쪼개기)
   * Syntax 체크 : 문법오류 쳌
   * Semantic 체크 : 의미상 오류 쳌(없는 컬럼 사용했는지 등)
2. SQL 최적화 (옵티마이저) -> 수집한 시스템, 오브젝트 통계정보 바탕 실행경로를 생성해 효율적인 하나를 선택
3. 로우 소스 생성 -> 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드/프로시저로 포멧팅

SQL 옵티마이저
* 사용자 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 액세스 경로 선택해주는 엔진.
1. 후보 실행계획 선출
2. 각 실행계획 예상비용 산정
3. 최저비용 실행계획 선택

실행계획
* 옵티마이저 실행경로 미리보기
* 7장에서 배울 비용을 근거로 실행계획 cost를 매겨 선출

옵티마이저 힌트
* 주석 기호에 +를 붙임 /*+Index(A 고객_PK) */

## 1.2 SQL 공유 및 재사용
소프트파싱 vs 하드파싱
* 라이브러리 캐시 -> 내부 프로시저를 반복 재사용 할 수 있는 공간
* SGA 구성요소 -> 서버프로세스, 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리공간
* 소프트파싱 : SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는것
* 하드파싱 : 찾는데 실패해서 최적화, 로우소스 생성 단계까지 거치는 것

파싱 중 옵티마이저가 사용하는 정보 -> 이렇게 많은 정보로 하드하게 작업함... -> 라이브러리 캐시가 필요한 이유
* 테이블, 컬럼, 인덱스 구조 기본정보
* 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼통계(by 히스토그램)
* 시스템 통계 : CPU속도, Single Block I/O속도, Multiblock I/O속도
* 옵티마이저 관련 파라미터

사용자가 정의하는 프로시저/트리거/패키지등은 라이브러리 캐시를 이용하여 재사용됨 -> SQL은 이름이 없음... 전체 SQL 쿼리 텍스트가 이름 역할을 함
* 공유가능 SQL
  * 파라미터만 바뀌는 SQL의 경우 -> 파라미터를 받는 프로시저 하나를 공유하면서 재사용하는 것이 효율적
  * 파라미터 Driven 방식으로 SQL을 작성하는 방법 : 바인드 변수

## 1.3 데이터 저장 구조 및 I/O 매커니즘
* I/O 튜닝 = SQL 튜닝
* SQL이 느린 이유 = I/O 때문

I/O
* 잠(SLEEP)
* 프로세스 = 실행중인 프로그램.
* 인터럽트에 의해 수시로 ready상태로 전환했다가 running상태로 전환...
* 인터럽트 없이 일하던 프로세스도 디스크에서 데이터 읽을땐 CPU를 OS에 반환하고 wating하다가 I/O완료 기다림
* == I/O가 많으면 느릴수밖에...

데이터베이스 저장 구조
* 테이블 스페이스 = 세그먼트를 담는 콘테이너... 여러 데이터파일로 구성됨
* 익스텐트 = 공간을 확장하는 단위. 연속된 블록의 집합.
  * 한 익스텐트도 하나의 테이블이 독점. 하나의 익스텐트에 담긴 블록은 모두 같은테이블 블록.
* 세그먼트 공간 부족 -> 테이블 스페이스로부터 익스텐트 추가 할당

용어 정리
* 블록 : 데이터를 읽고 쓰는 단위
* 익스텐트 : 공간을 확장하는 단위. 연속된 블록 집합
* 세그먼트 : 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
* 테이블스페이스 : 세그먼트 담는 콘테이너
* 데이터파일 : 디스크상의 물리적인 OS파일

블록단위 I/O
* 데이터베이스에서 데이터를 읽고쓰는단위 = 블록
* 특정 레코드 하나를 읽고 싶어도 블록을 통째로 읽음

시퀀셜 액세스 vs 랜덤 액세스
* 시퀀셜 액세스는 논리/물리적으로 연결된 순서에 따라 순차적으로 블록을 읽는 방식
* 랜덤 액세스는 순서 따지지 않고 레코드 읽기 위해 한 블록씩 접근하는 방식

논리적I/O, 물리적 I/O
* DB 버퍼캐시 = 데이터 캐시. 디스크에서 읽은 블록을 캐싱해두는 것
* 논리적 블록 I/O = SQL 처리 과정에서 발생한 총 블록 I/O (SQL을 수행하면서 읽은 총 블록I/O -> 일반적으로 DB버퍼캐시에서 블록을 읽은 횟수)
* 물리적 블록 I/O = 디스크에서 발생한 총 블록 I/O. 논리적 I/O중 일부를 물리적으로 I/O함 (버퍼캐시에서 찾지 못해서 디스크에서 읽은 블록I/O)
* 버퍼캐시 히트율(BCHR) = (캐시에서 찾은 블록수/총 블록수) * 100 = ((논리적IO-물리적IO)/논리적IO)*100 = (1-(물리적IO/논리적IO)) * 100
* 논리적 IO를 줄이는 방법 = SQL튜닝! -> 논리적IO를 줄임으로서 물리적 IO도 줄이는게 SQL튜닝
* BCHR이 높다고 해서 반드시 꼭 효율적인 SQL은 아니다...

SingleBlock I/O vs Multiblock I/O
* SingleBlock I/O : 한 번에 한 블록씩 요청해서 메모리에 적재
  * 소량의 데이터를 읽을때 주로 사용
  * 인덱스 루트블록/인덱스 리프블록 등...
* Multiblock I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재
  * 많은 데이터 블록 읽을때 사용
  * 캐시에서 찾지 못한 특정 블록 찾으려고 IO call 할 때 디스크상 인접한 블록 한번에 읽어 캐시에 적재하는 기능

Table Full Scan vs Index Range Scan
* Table Full Scan 찾아내기식 실행계획 분석? => SQL 성능 향상에 큰 도움 안됨. 오히려 인덱스가 SQL 성능 떨어뜨리는 경우도 상당히 많음
* 한 번에 많은 데이터 처리하는 집계용 SQL, 배치 프로그램은 특히 풀스캔이 인덱스보다 효율적.
* 풀스캔은 Multiblock I/O로 데이터 읽고 인덱스 스캔은 Singleblock I/O로 읽음 -> 많은 데이터를 읽을때는 테이블 풀스캔보다 불리

캐시 탐색 매커니즘
* Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유함
* 버퍼캐시에서 블록 찾을땐 **해시알고리즘**으로 버퍼헤더를 찾아 버퍼블록에 액세스...
* 메모리 공유자원에 대한 액세스 직렬화
  * 하나의 블록에 두 개 이상 프로세스가 동시에 접근하려 할 때 문제 발생 -> 자원 공유하는것처럼 보여도 내부에서는 한 프로세스씩 순차접근 하도록 구현해야 함 -> 직렬화 매커니즘 (줄세우기)
  * 직렬화 매커니즘에 의한 캐시 경합 줄이기 위해서는 SQL 튜닝으로 쿼리 일량(논리IO) 자체를 줄여야 함