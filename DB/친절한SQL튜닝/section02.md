# 2장. 인덱스 기본
## 2.1 인덱스 구조 및 탐색
DB에서 데이터를 찾는 두 가지 방법
* 테이블 전체를 스캔
* 인덱스를 이용

인덱스 튜닝의 두 핵심요소
* 인덱스 스캔의 효율화 튜닝
  * 인덱스 순서
* 랜덤 액세스 최소화 튜닝
  * 디스크에 접근하는 횟수
* 둘 중 뭐가 더 중요? -> 랜덤 액세스 튜닝.. 성능에 미치는 영향이 더 큼. SQL튜닝은 랜덤IO와의 전쟁

인덱스 구조
* Range Scan이 가능 -> 인덱스가 정렬되어 있기 때문
* DBMS는 기본적으로 B-Tree인덱스 사용
  * 리프 블록에 저장된 각 레코드는 키값으로 정렬되어 있고, 테이블 레코드 주소값(ROWID)을 가짐 -> ROWID를 알면 테이블 레코드를 찾아갈 . 수있음.
  * ROWID = 데이터 블록 주소 + 로우 번호
  * 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  * 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
  * 로우 번호 : 블록 내 순번

인덱스 탐색 과정
* 수직적 탐색 : 인덱스 스캔 시작 지점 찾는 과정
  * 루트블록에서 찾고자 하는 값 까지 하위블록으로 이동.
  * 하위로 이동하면서 조건을 만족하는 첫 번째 블록을 찾는 과정
* 수평적 탐색 : 데이터 찾는 과정
  * ROWID를 이용해 테이블에 액세스

## 2.2 인덱스 기본 사용법
가공한 값이나 중간값을 찾으면 인덱스를 정상적으로 사용할 수 없음 -> 리프블록 전체를 스캔해야 함(Index Full Scan)
* 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다 => 인덱스 시작점을 찾을 수 없기 때문
* 인덱스 순서!!! 진짜 중요함
  * 인덱스의 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 인덱스를 Range Scangkf tn dlTek.

인덱스를 타면 끝?
* 스캔 범위를 줄이지 못하면 무용지물

인덱스를 이용한 소트 연산 생략
* 인덱스는 이미 정렬되어 있음 -> 소트 효과 부수적으로 얻게됨

ORDER BY 절이나 SELECT-LIST 에서의 가공 때문에 인덱스를 정상 사용 못하는 경우
* 가공한 값을 정렬해달라고 요청했거나...하는 경우
* 가공한 값의 최댓값 ex) MAX(TO_NUMBER(변경순번)) 과 같이 가공한 값을 기준으로 연산을 할경우
  * 위 경우는 그냥 TO_NUMBER(MAX(변경순번)) 하면 해결됨

자동 형변환
* 생년월일이 date 인덱스라고 가정했을 때 -> `WHERE 생년월일 = 19990922` 하면 `WHERE TO_NUMBER(생년월일) = 19990922` 로 자동형변환 되어 인덱스를 타지 못함
  * `WHERE 생년월일 = TO_DATE(19990922, 'YYYYMMDD')`


## 2.3 인덱스 확장 기능 사용법
### 2.3.1 Index Range Scan
* B-Tree 인덱스의 일반적인 액세스 방식
* 리프블록까지 수직적 탐색 후 필요한 범위만 스캔
* 선두컬럼을 가공하지 않은 상태로 조건절에 사용
* -> 성능이 무조건 OK는 아니고 스캔 범위, 테이블 액세스 횟수를 줄일수 있느냐로 결정됨

### 2.3.2 Index Full Scan
* 인덱스 리프블록을 처음부터 끝까지 스캔
* 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택
* 대용량 테이블이라 테이블 풀스캔에 대한 부담이 될때 / 인덱스 일부만 테이블 액세스 하는 상황 / 인덱스를 이용한 소트 연산 생략

### 2.3.3. Index Unique Scan
* 유니크한 인덱스를 = 조건으로 탐색하는 경우
* 수직적 탐색만으로 레코드 탐색하는 경우

### 2.3.4 Index Skip Scan
* 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 새로운 스캔 방식
* 루트/브랜치 블록에서 읽은 컬럼 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스
* Distinct Value 개수가 적은 선두 컬럼이 조건절에 없고, 후행 컬럼의 Distinct Value 개수가 많을 때 효과적
* Index Range Scan이 불가하거나 효율적이지 못한 상황에서 효과적.
* 조건에 맞느 레코드를포함할 가능성이 있는 리프블록만 골라서 액세스
* But... 최적의 레인지 스캔을 목표로 설계해야 하고, 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는게 비효율적일 때 해당 스캔방식을 차선책으로 선택해야 함

### 2.3.5 Index Fast Full Scan
* 인덱스 풀스택보다 빠름
* 인덱스 풀스캔은 논리적 구조를 따라 블록을 순서대로 읽음
* Index Fast Full Scan은 물리적 순서대로 읽음 -> 인덱스가 파티션 되어 있지 않아도 병렬 쿼리가 가능함
  * Direct Path IO방식을 사용

### 2.3.6 Index Range Scan Descending
* 인덱스 레인지 스캔과 기본적으로 동일한 스캔 방식
* 인덱스를 뒤->앞으로 스캔해서 내림차순으로 정렬된 결과집합을 얻음
