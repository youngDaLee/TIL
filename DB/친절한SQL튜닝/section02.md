# 2장. 인덱스 기본
## 2.1 인덱스 구조 및 탐색
DB에서 데이터를 찾는 두 가지 방법
* 테이블 전체를 스캔
* 인덱스를 이용

인덱스 튜닝의 두 핵심요소
* 인덱스 스캔의 효율화 튜닝
  * 인덱스 순서
* 랜덤 액세스 최소화 튜닝
  * 디스크에 접근하는 횟수
* 둘 중 뭐가 더 중요? -> 랜덤 액세스 튜닝.. 성능에 미치는 영향이 더 큼. SQL튜닝은 랜덤IO와의 전쟁

인덱스 구조
* Range Scan이 가능 -> 인덱스가 정렬되어 있기 때문
* DBMS는 기본적으로 B-Tree인덱스 사용
  * 리프 블록에 저장된 각 레코드는 키값으로 정렬되어 있고, 테이블 레코드 주소값(ROWID)을 가짐 -> ROWID를 알면 테이블 레코드를 찾아갈 . 수있음.
  * ROWID = 데이터 블록 주소 + 로우 번호
  * 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  * 블록 번호 : 데이터 파일 내에서 부여한 상대적 순번
  * 로우 번호 : 블록 내 순번

인덱스 탐색 과정
* 수직적 탐색 : 인덱스 스캔 시작 지점 찾는 과정
  * 루트블록에서 찾고자 하는 값 까지 하위블록으로 이동.
  * 하위로 이동하면서 조건을 만족하는 첫 번째 블록을 찾는 과정
* 수평적 탐색 : 데이터 찾는 과정
  * ROWID를 이용해 테이블에 액세스

## 2.2 인덱스 기본 사용법
가공한 값이나 중간값을 찾으면 인덱스를 정상적으로 사용할 수 없음 -> 리프블록 전체를 스캔해야 함(Index Full Scan)
* 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다 => 인덱스 시작점을 찾을 수 없기 때문
* 인덱스 순서!!! 진짜 중요함
  * 인덱스의 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 인덱스를 Range Scangkf tn dlTek.

인덱스를 타면 끝?
* 스캔 범위를 줄이지 못하면 무용지물

인덱스를 이용한 소트 연산 생략
* 인덱스는 이미 정렬되어 있음 -> 소트 효과 부수적으로 얻게됨

ORDER BY 절이나 SELECT-LIST 에서의 가공 때문에 인덱스를 정상 사용 못하는 경우
* 가공한 값을 정렬해달라고 요청했거나...하는 경우
* 가공한 값의 최댓값 ex) MAX(TO_NUMBER(변경순번)) 과 같이 가공한 값을 기준으로 연산을 할경우
  * 위 경우는 그냥 TO_NUMBER(MAX(변경순번)) 하면 해결됨

자동 형변환
* 생년월일이 date 인덱스라고 가정했을 때 -> `WHERE 생년월일 = 19990922` 하면 `WHERE TO_NUMBER(생년월일) = 19990922` 로 자동형변환 되어 인덱스를 타지 못함
  * `WHERE 생년월일 = TO_DATE(19990922, 'YYYYMMDD')`


## 2.3 인덱스 확장 기능 사용법
