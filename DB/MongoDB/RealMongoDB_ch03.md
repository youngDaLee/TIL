# Real MongoDB - ch03. 복제
- 마스터 - 슬레이브 복제 : 권장 X
- 레플리카셋 복제 : 안정. 권장

## 3.1 복제란?
- 물리적 복제 : 리얼로 그냥 HDD를 복제(시스템은 안에 뭐가 들었는지 모름)
- 논리적 복제 : MySQL, MongoDB등에서 DB서버가 직접 서버간 데이터 동기화하는거

### 3.1.1 컨센서스 알고리즘(Consensus Algorithm)
- 레플리카셋 : 데이터를 공유하는 그룹
- 컨센서스 알고리즘 : 특정 노드가 응답불능 상태일 때 어떻게 대처할지를 결정
MongoDB는 Raft 컨센서스 알고리즘을 채택함
- 리더 기반 복제
- 하나의 레플리카에는 하나의 리더만 있음. 팔로워는 리더 로그를 가져와서 동기화 수행함
  - 리더 = 프라이머리 노드(Primary Node)
  - 팔로워 = 세컨드리 노드(Secondary Node)
  - 로그 = OpLog(Operation Log)

### 3.1.2 복제의 목적
- 데이터 손실해도 다른 멤버 데이터로 대체할 수 있도록 함
  - 고가용성(High Avalability)을 위해 중복(Data Redundancy)된 데이터셋 준비

- 하트비트(Heartbeat) 메세지 : 노드 살아있는지 확인하는 통신 주고받는거

- 보통은 레플리카셋 3대정도로 구성함. 조회 쿼리가 아주 많은 서비스에서는 복제를 더 추가 할 수도 있음
- 서비스 도중에 물리적 백업(온라인 백업)기능 제공안함. 세건드리 멈추고 데이터 파일 복제해야 할 수도 있음


## 3.2 레플리카 셋 멤버
- 최대 50개 멤버가 복제 참여 가능(MongoDB 3.x버전에서.. ), 프라이머리 멤버 선출은 8개까지만 가능
  - 최신버전(6.0)에서도 아직 최대 멤버 50개/멤버 7개 투표 가능 https://www.mongodb.com/docs/manual/core/replica-set-members/

### 프라이머리(Primary)
- 데이터 변경을 처리할 수 있는 유일한 멤버
- 사용자 데이터 변경 요청 처리, 변경된 데이터를 OpLog에 기록 -> 레플리카셋 멤버들이 OpLog보고 데이ㅓㅌ 동기화 함
- 프라이머리 꺼지면 데이터 변경 안되는데, 이 때 투표를 통해 바로 다른 프라이머리 선출함

### 세컨드리(Secondary)
- 프라이머리 OpLog가져와서 프라이머리랑 동일한 데이터셋 유지함
- 1개 이상 존재 가능
- 읽기만 가능
- 읽기쿼리 분산용도
- hidden 옵션으로 세컨드리 접속 막을 수 있음
- 고가용성. 쿼리 분산 용도 -> 데이터 백업과는 거리가 멀다
  - 변경 내용 실시간 반영해서 프라이머리 데이터 유실되면 세컨드리도 데이터 유실됨
  - 따라서 오프라인 상태의 백업 필수

### 아비터(Arbiter)
- 레플리카셋 멤버로 참여해서 프라이머리 선출에는 관여하는데 실제 사용자 데이터는 전혀 가지지 않고, OpLog도 가져오지 않음
- 프라이머리 선출용
  - 레플리카셋이 반드시 과반수 이상의 멤버가 투표 참여해야 프라이머리 선출 되는데, 멤버 과반수 이상이 죽으면 프라이머리 선출 불가 -> 이 때 레플리카 투입되는건 시간 너무 지체됨 -> 빠르게 투표할 수 있는 애(아비터) 투입함
  - MongoDB 고가용성(HA)위해 레플리카셋 3대 서버 비용 부담... -> 프라이머리서버/프라이머리 스탠바이서버(레플리카. 세컨드리) 이렇게 두 대만 놓고, 한 대에서 가상서버 열어서 아비터 투입 -> 총 3대 (프라이머리(물리), 세컨드리(물리), 아비터(가상)) -> 보다 저렴하지만 비슷한 수준의 가용성 보여줌
- 데이터 관련해서 하는게 없어서 높은사양 하드웨어 필요치 암ㅎ음
- 서버 한대에서 아비터 인스턴스 여러 대 실행해서, 서로 다른 레플리카셋에 투입시키는 방법도 있음


## 3.3 프라이머리 선출(Primary Election)
- 선출해야 하는 이유 : 레플리카셋에 프라이머리가 없어서

### 3.3.1 프라이머리 텀(Primary Term)
- MongoDB 3.0 이전 : 프라이머리 텀의 개념이 없음. 중복투표로 인한 투표 실패 위험 -> 투표 실패하는 시간동안 프라이머리 없음! 위험!
- MongoDB 3.2 부터... : 프라이머리텀이 투표식별자. 투표를 할 때 마다 Primary Term 증가 -> Primary Term으로 투표 여부도 확인 가능
  - 투표 실패하면 1 증가한 Primary Term으로 투표함(30초나 기다리는게 아니라!)

### 3.3.2 프라이머리 스텝 다운(Primary Step Down)
프라이머리가 없어졌을 때 뿐만 아니라, 관리자가 강제로 프라이머리를 재지정 하는 것도 가능.
- 프라이머리 스텝 다운 : 프라이머리를 세컨드리로 내리는 것
  - `rs.stepDown(프라이머리가 다시 세컨드리로 지정되지 않을 시간, 프라이머리를 선출하지 않을 시간)`
- 레플리카셋의 우선순위(Priority) 변경
  ```
var cfg = rs.conf()
cfg.members[1].priority=2  # index 1번째 멤버의 priority를 2로 변경
rs.reconfig(cfg)  # 변경된 설정으로 재설정```

MongoDB 내부적으로는 `rs.stepDown` 과 `rs.reconfig` 처리 로직이 동일.
- `rs.reconfig` == `rs.stepDonw(60,10,true)`
- 다만 reconfig시, 프라이머리가 될 세컨드리가 동기화 할 시간을 주지 않고 바로 프라이머리 선출을 하여 데이터 롤백이 발생할 가능성이 높아짐.

### 3.3.3 프라이머리 선출 시나리오
- 레플리카셋 모든 멤버는 서로간 하트비트 메세지를 주고받음
  - 투표 참여 인원 7대인 이유... -> 멤버 많아질수록 하트비트 메세지 많아셔서 부담감

1. 세컨드리는 전송한 하트비트에 대해 지정된 시간(electionTimeoutMillis)동안 응답 기다림
2. 응답이 없는 경우 새로운 투표 시작
  - 서버는 정상 작동하나 멤버간 연결에만 이슈가 생긴 경우, 스플릿 브레인 현상 발생 가능(기존 프라이머리가 여전히 사용자 요청 처리)
3. 자가 선출(Self-Election) 진행
  - 레플리카셋에서 프라이머리가 없어지면 자기 자신을 후보로 세움. 다른 서버에 내가 지금 프라이머리가 돼도 괜찮은지 결과를 전달함. 몇 가지 체크사항을 체크한 뒤 해당 세컨드리를 프라이머리로 선출함
    - 세컨드리(A)가 나(세컨드리 B)와 같은 레플리카셋 소속 멤버인가
    - 세컨드리(A)의 우선순위가 현재 레플리카셋의 모든 멤버의 우선순위와 같거나 큰 값인지
    - A가 요청한 투표의 Term이 B가 참여했던 Term보다 큰 값인지
    - A가 요청한 투표의 Term에 B가 투표한 적 없는지
    - A가 B보다 최신이거나 동등한 데이터를 가지고 있는지(OpLog의 OpTime이 더 최신이거나 동등한 시점인지)
  - 위 다섯개가 다 참인 경우에만 찬성 메세지를 보냄
    - 만약 거부가 된다면 프라이머리 선출에 실패하게 되었던 Protocol Version 0 / Version 1에서는 거부 없이 선출텀만 증가시키면 지연 없이 바로 투표 시작 가능(거부권과 동시에 새로운 투표 시작)

### 3.3.4 프라이머리 선출 시 정족수(Quorum)의 의미

### 3.3.5 롤백(Rollback)
MongoDB의 롤백은 RDBMS의 트랜잭션 롤백과 다른 의미임.
- MongoDB의 롤백 : 레플리카셋 각 멤버끼리 데이터를 동기화하는 과정에서 이미 저장된 데이터를 다시 삭제하는 과정

롤백 시나리오
- 프라이머리에 특정 데이터가 기록된 뒤, 해당 데이터가 복제되기 전에 프라이머리가 네트워크 이슈로 끊기고, 다른 멤버가 프라이머리로 선출되어 일부 데이터가 복제 없이 누락되는 현상
- Oplog 시점을 모두 맞춰주야 함-> 기존 서버에서 다른 서버에 누락된 데이터를 삭제해주는 식으로 동작하게 됨

### 3.3.6 롤백 데이터 재처리
롤백데이터는 MongoDB 서버 디렉터리 하위에 rollback으로 생성됨.
- 취소된 변경 되이터는 BSON 형태로 기록함
- bsonbackup  유틸리티로 JSON으로 변경 가능

```
# rollback 파일
<database>.<collection>.<timestamp>.bson

# BSON to JSON
>>> bsondump mydb.mycoll.2022-10-10T00-00-00.0.bson > rollback_mycoll.json

# BSON 출력을 mongoimport 형태로 전달(MongoDB로 저장)
>>> bsondump mydb.mycoll.2022-10-10T00-00-00.0.bson | mongoimport --db mydb --collection mycoll
```

## 3.4 복제 아키텍쳐
MongoDB 복제는 하나의 프라이머리와 여러 세컨드리로 구성됨.   
OpLog 재생은 실시간으로 변경되는 데이터에 동기화 하는 것. 실제 MongoDB 복제 동기화는 초기 동기화(Initial Sync)/실시간 복제(Replication) 두 가지로 나뉨

### 3.4.1 복제로그(OpLog)구조
DB의 oplog.rs라는 이름의 컬렉션으로 기록함.

oplog.rs의 필드들
- ts (Timestamp)
- t (Primary Term)
- h (Hash)
- v (Version)
- op (Operation Type)
- ns (Namespace)
- o (Operation)
- o2 (Operation2)

### 3.4.2 local 데이터베이스
- oplog.rs를 포함해 몇 개의 MongoDB 서버 자신을 위한 컬렉션을 생성하는데, 그 컬렉션들이 저장되는 DB가 local 데이터베이스
- local 데이터베이스의 컬렉션은 세컨드리에서도 INSERT, UPDATE, DELETe 수행 가능

### 3.4.3 초기 동기화(Initial Sync)
- 데이터 디렉토리가 비어있는 상태에서 레플리카셋 투입되는 경우.
- 부트스트랩(Bootstrap) : 이미 데이터를 가지고있는 MongoDB에 새로운 멤버 투입하는 것
- 주의사항
  - 단일스레드로 진행되기 때문에 오랜 시간 소요.
  - 중간에 멈췄다 다시 시작하는 경우 처음부터 해야 함

#### 수동 초기 동기화
정상적인 레플리카 데이터파일 그대로 복사해서 새로운 멤버 데이터 디렉토리로 복사하는 것 = 부트스트랩
1. 데이터 파일 복사
2. MongoDB 서버 시작

데이터 크기가 1~2 TB가 넘어간다면 초기 동기화 시간이 1~2주를 넘길 수 있는데, 이 때 추천하는 방식.
#### 자동 초기 동기화
MongoDB 서버가 다른 멤버로무터 DB 복사하는 방법
1. DB 복제(clone)
2. OpLog를 이용한 데이터 동기화
3. 인덱스 생성

관리 비용이 많이 들지 않음

### 3.4.4 실시간 복제(Replication)


## 3.5 복제 로그(Operation Log) 설정


## 3.6 레플리카셋 설정


## 3.7 레플리카셋 베포

