# AI 애플리케이션을 위한 데이터 모델링

## 데모

## 데이터 해부
컴퓨팅 & AI모델 -> 데이터 & 툴 -> 앱
* 어플리케이션 라이프사이클이 끊임없이 확장되기 때문에 data가 전체 라이프사이클 측면에서 중요한 존재가 될 수 있다.

비정형 데이터 활용
메타데이터 활용
* AI는 쌓인 데이터를 찾아서 가치를 찾아내는게 주.
* 낡은 데이터를 학습시키는 것이 주요 -> 레거시는 데이터가 쌓여있다.
* 그 데이터에 AI 어플리케이션이 접근해서 활용하는게 중요하다.
* 서로다른 시스템에서 자유롭게 접근하는게 바람직한 환경은 아니다...
* 레거시가 갖고있는 낡은 데이터/실시간 데이터만 사용하는것도 아니고, 새로운 데이터-프롬프트에 대한 데이터도 가지고 있어야한다.
* 재미나이는 컨텍스트 100만개 처리 가능한 성능을 가지고 있다. 과거기록을 활용해서 생성형AI로 예측서비스

=>데이터 저장소 필요 조건
* 레거시 시스템 데이터
* 장기분석 데이터
* 현업 실시간 데이터
* OLTP 성향도 가지고 있고, 분석 성향도 가지고 있고, 데이터마트 역량도 가지고 있어야 AI어플리케이션이 서비스 . 될수. ㅣㅆ다.

## ODL 해부
싱글뷰
* customer 360 -> 여러 데이터를 한곳에 모아서 활용하는 구조. AI서비스에서는 이러한 싱글뷰가 절대적으로 필요함
* AI어플리케이션을 점진적으로 확장해나가야함. 그런 측면에서 스키마가 끊임없이 변한다는 특징이 있음.
* OLTP
* Row기반 DB
* 인덱싱
* ==>> JSON document DB

벡터 & 메타데이터
* 관계와 동기화
* 관계 형성의 용이함
* 한번에 검색
* 개발생산성 & 단일쿼리
* 실시간 동기화
* 독립형
* 검색엔진 통합형
  * 메타데이터가 실시간으로 추가/업데이트 되는 변화를 실시간 반영해야 하는데 업데이트에 어려움이 있음.
  * 검색엔진으로 워크로드 서비스를 다르는 앱을 아직 본적 없음 (ㅋㅋ;;;;;;;)

확장성
* 메타데이터와 백터의 분리
* 자원은 분리하고
* 운영/검색은 통합하자

SQL이 영원할것이란 생각을 버리고 JSON에 집중해보자

LLM/RAG
* 벡터 검색
  * training한 데이터에 종속되는 특징이 있기 때문에 벡터DB에 너무 의존하지 않는 것이 좋음
  * 그 때 마다 모델 다시 트레이닝 하는 것은 불가하니 -> prefilter를 통해 검색대상을 사전에 걸러내기도 하고, full text search를 이용해서 검색 결과를 결합하는 방식도 고려하고 있음.
* 메타데이터 필터
* 키워드 검색

## 데이터 모델링
벡터와 메타데이터
* 벡터도 임베딩이나 레퍼런싱을 할 수 있음.
* e임베딩의 장점ㅇ느 : 메타데이터 쉽게관리 가능
* 만약 메타데이터가 너무 많은 업데이트가 생기면 작은 메타데이터 업데이트를 위해 전체 도큐먼트에 계속 접근해야하는 성능저하를 견뎌내야함.

메타데이터에 필터 포함(pre-filter)
* 검색속도 향상
* 정확도 향상
* 동적인 JSON 스키마
* => 이상적인 검색 결과를 가져올 수 있다.
* 이러한 prefilter를 어떻게 관리할것인가? -> JSON다큐먼트가 아니면 변화하는 스키마를 감당하기 어려울것이다.

잡종검색(하이브리드 서치) -> Single collection pattern
* 한 번의 쿼리로 벡터&키워드 동시검색
* 공통 필드로 묶기 -> 검색 . 후처리
* 메타데이터와 벡터도큐먼트를 같이 저장해두고, page_number같은 키를 같이 저장. -> 벡터검색도하고 필터검색도 한 뒤에 page_number로 다시 묶어 결과를 리턴
  * JOIN 없이 검색을 향상시킬 수있는 데이터 모델링

Atlas Vector Search
* OLTP & 실시간 DB
* 데이터 파이프라인 없이 MSA 구성 가능
* 운영자원과 검색자원 분리
