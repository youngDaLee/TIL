# ch04. 데이터베이스
## 4.1 데이터베이스의 기본
* DB: 일정한 규칙을 통해 구조화되어 저장되는 데이터 모음. 관리되는 통합 시스템을 DBMS(Database Management System)
  * DB 위에 DBMS가 있고, 그 위에 응용프로그램이 있음

엔티티(entity)
* 속성(이름, 아이디, 주소, 전화번호 등...)을 지닌 **명사** ex) 회원...
* 약한 엔터티와 강한 엔터티
  * A가 혼자 존재 못하고 B의 존재 여부에 따라 종속적
  * 약한 엔터티 : A (ex: 방)
  * 강한 엔터티 : B (ex: 건물)
  * 내가 생각하는 약한/강한 엔터티 : 게시글(강), 태그(약)

릴레이션(relation)
* 정보를 구분해서 저장하는 기본 단위
* 엔터티를 릴레이션 하나에 담아 관리함
* 릴레이션
  * in RDBMS : 테이블 (MySQL : 레코드 - 테이블 - 데이터베이스)
  * in NoSQL : 컬렉션 (MongoDB : 도큐먼트 - 컬렉션 - 데이터베이스)

속성(attribute)
* 릴레이션의 정보

도메인(domain)
* 릴레이션의 각 속성이 가질수 있는 값의 집합

필드와 레코드
* row

MySQL 기준의 필드 타입
* 숫자
  * TINYINT (1 byte)
  * SAMLLINT (2 byte)
  * MEDIUMINT (3 byte)
  * INT (4 byte)
  * BIGINT (8 byte)
* 날짜
  * DATE (3 byte)
  * DATETIME (8 byte)
  * TIMESTAMP (4 byte)
* 문자
  * CHAR : 고정길이 문자열
  * VARCHAR : 가변길이 문자열
  * TEXT : 큰 문자열
  * BLOB : 이미지, 동영상 등 큰 데이터 저장
  * ENUM : 도메인을 지정해서 저장할 수 이쎅 함. 열거 타입
  * SET : ENUM과 비슷하지만 여러 데이터를 선택할 수 있음

관계
* 테이블간의 관계

키
* 기본키(PK) : 유일성, 최소성
  * 자연키 : 중복되지 않는거 자연스럽게 뽑는거... 언젠가 변함 / 인조키 : 인위적으로 부여하는 키
* 외래키(PK) : 다른 테이블 기본키 참조. 관계 식별에 사용
* 후보키 : 기본키가 될 수 있는 후보. 유일성, 최소성
* 대체키 : 기본키를 제외한 후보키
* 슈퍼키 : 유일성

## 4.2 ERD와 정규화 과정
ERD(Entity Relationship Diagram) : DB 구축의 뼈대 역할. 릴레이션간의 관계

ERD의 중요성
* 설계요
* 비정형 데이터를 충분히 표현할 수 없다는 단점...
  * 그래서 Hackolade 같은 툴이 나오고 있음
  * 내 생각에는.. MongoDB와 같은 비정형 데이터여야말로 ERD 잘써야 한다고 생각함... 까딱하면 필드 지맘대로 쓸 수 있기 때문

정규화과정
* 릴레이션간 잘못된 종속 관계 해결하거나, 저장공간 효율적으로 사용하기 위함
* 정규형 원칙 : 좀 더 좋은 구조로 자료의 중복성은 줄이고 독립적인 관계는 별개의 릴레이션으로 표현하고, 각각의 릴레이션은 독립적인표현이 가능해야 한다~

제1정규형
* 릴레이션 모든 도메인이 분리될 수 없는 원자값(atomic value)으로 구성되어야 함
* = 필드에 리스트가 없어야 한다~

제2정규형
* 릴레이션이 제1정규형이며 부분함수의 종속성을 제거한 형태
* 부분함수의 종속성 제거 : 기본키가 아닌 모든 속성이 기본키에 완전함수 종속적
  * 기본키 분리

제3정규형
* 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(FD)을 만족시키지 않는 상태
* 이행적 함수 종속
  * A -> B, B -> C 가 존재하면 논리적으로 A->C가 성립 = C가 A에 이행적 함수 종속이다

BCNF(보이스/코드 정규형)
* 제3정규형이고, 결정자가 후보키가 아닌 종속관계를 제거하여 릴레이션 함수 종속 관계에서 모든 결정자가 후보키인 상태
  * 결정자 : 함수 종속 관계에서 종속자를 결정짓는 요소. X->Y에서 X는 결정자/Y는 종속자

정규화를 많이 거친다고 성능이 나아지는게 아님.. 때에따라 비정규화 들어가야 성능 나아지기도 함..


## 4.3 트랜잭션과 무결성
트랜잭션 : DB에서 하나의 논리적 기능을 수행하기 위한 작업의 단위.

### ACID (원자성, 일관성, 독립성, 지속성)
원자성(Atomicity)
* 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장
* 커밋
  * 여러 쿼리가 성공적으로 처리되었다~
* 롤백
  * 취~소
* 트랜잭션 전파 : 여러 트랜잭션 관련 메서드 호출을 하나의 트랜잭션에 묶이도록 하는 것
  * 스프링은 @Transactional을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리함

일관성(consistency)
* 허용된 방식으로만 데이터를 변경해야 하는 것

격리성(isolation)
* 트랜잭션 수행 시 서로 끼어들지 못하도록하는 것.
* 여러 수준으로 나눠 격리성을 보장함
  * SERIALIZABLE : 트랜잭션을 순차적으로 진행시키는 것. 엄격. 성능은 떨어짐
  * REPEATABLE_READ : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수행할 수 없도록 막지만, 새로운 행을 추가하는건 막지 않음(팬텀리드 발생 가능)
  * READ_COMMITTED : 가장많이 사용.커밋하지 않은 정보는 읽을 수 없으(커밋된 데이터만 읽음) non-repeatable read 발생 가능
  * READ_UNCOMMITTED : 가장 낮은 격리수준. 빠름. 무결성은 보장 못하는데...
* 격리 수준에 따라 발생하는 현상
  * 팬텀리드 : 한 트랜잭션 내 동일 쿼리를 보냈을 때 조회 결과가 다른 경우
  * non-repeatable read : 한 트랜잭션 내 같은 행에 두 번 이상 조회가 발생했는데 값이 다른 경우
  * dirty-read : 커밋되지 않은 행의 데이터를 읽을 수 있을 때

지속성(durability)
* 커밋된 트랜잭션 영구 반영됨
  * 체크섬, 저널링, 롤백등을 지원함

### 무결성
데이터의 정확성, 일관성, 유효성을 유지하는 것. DB 값과 현실값이 일치하는지에 대한 신뢰...
* 개체 무결성 : 기본키로 선택된 필드는 빈값 허용 x
* 참조 무결성 : 서로 참조 관계 있는 테이블 데이터는 일관값 유지함
* 고유 무결성 : 특정 속성에 대해 고유값 가지도록 조건이 주어진 경우, 속성값 모두 고유값 가짐
* NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건 주어진 경우 속성값 NULL 될 수 없음

## 4.4 데이터베이스 종류
### RDBMS(관계형 데이터페이스)
* 행과열, SQL
* 대표젹으로 MySQL, PostgreSQL, Oracle, MSSQL 등...

### NoSQL
* SQL을 쓰지 않음
* MongoDB, Redis

## 4.5 인덱스
인덱스 쓰면 뭐가 좋음? : 읽기 성능~

인덱스 최적화 기법(MongoDB 기준)
* 인덱스는 비용이다 => 인덱스 -> 원본 데이터 이렇게 두 번 탐색하게 됨. 무작정 다 인덱싱 하는 것 보다 적절하게 걸어야 함..
* 항상 테스팅해라
* 복합인덱스는 같음,정렬,다중값,카디널리티 순이다...
  * == 쿼리가 자주 사용되는 필드가 첫번째 값으로 설정
  * 정렬에 쓰는 필드를 그 다음 인덱스로 설정
  * 다중값(범위검색) 많이 쓰는 필드를 그 다음 인덱스로 설정
  * 유니크한 값의 정도(카디널리티.... 성별은 카디널러티가 더 낮고, id는 카디널러티가 높다)가 높은 값을 인덱스로 설정해야 함

## 4.6 조인의 종류
조인 : 두 개 이상 테이블 묶는거
* MySQL은 JOIN, MongoDB는 lookup으로 사용 가능한데.. 몽고는 성능 너무 떨어져서 안씀

조인 종류
* INNER JOIN : 교집합
* LEFT JOIN : 왼쪽에 일치한 레코드 집합.
* RIGHT JOIN : 오른쪽에 일치한 레코드 집합
* FULL OUTER JOIN : 합집합

## 4.7 조인의 원리
중첩 루프 조인(NLJ, Nested Loop Join)
* 중첩 for문과 같이 양쪽 테이블 전부 다 돌며 조건에 맞는 조인을 하는 방법. 랜덤 접근이 많아 대용량 테이블에서는 하지 않음

정렬 병합 조인
* 각각의 테이블을 조인할 필드 기준으로 정렬하고, 정렬 이후 조인하는 것
* 인덱스가 없고 대용량 테이블 조인하고 비교연산자 있을 때 씀

해시 조인
* 해시테이블 기반 조인
* 중첩루프조인보다 효율적

## 질문
* DB와 DBMS의 차이가 무엇인가요?
* ACID 중 격리성이 보장되어야 하는 이유는 무엇인가요? 예시를 들어 설명해봅시다...
* 해시 조인이 사용 가능한 조건이 있나요? 해시 조인에 대해 설명해봅시다...

새롭게 알게된거
* 릴레이션 = 관계 로 항상 잘못 쓰는듯... 테이블/컬렉션은 테이블/컬렉션인줄