# Go와 Java에서의 변수의 저장 방식과 포인터
최근 Go 언어로 개발을 하면서, Java와 직접적으로 다르다고 느껴지는 부분이 변수가 메모리에 저장되는 방식과 포인터에 대한 부분이다.   
이 부분이 명확하게 설명하기 어려워 정리해보고자 한다

## 1. Go와 Java가 변수 선언을 할 때 메모리에 저장되는 방식
Go와 Java 모두 변수를 선언하면 메모리에 할당된다. 다만 두 언어의 메모리 관리 방식에는 차이가 있다.
### 1.1 Java T 메모리
Java 책 중 "스프링 입문을 위한 자바 객체지향의 이해와 원리(aka. 개구리책)" 에서는 자바의 메모리 영역을 "T메모리 영역"으로 구분하여 설명하였다.

T메모리 영역
* 데이터 저장 영역(static영역) : 클래스들 존재
  * 키워드 : 모든 영역에서 공유. 불변. 메모리상 단 하나의 영역
  * 클래스 멤버 = static 멤버 = 정적 멤버
* 스택(stack)영역 : 메서드들 존재
  * local 변수 = 지역변수
  * 메서드 호출에 대한 정보를 저장하는 공간
  * Java에서 메서드가 호출될 때마다 해당 메서드의 스택 프레임이 생성되어 스택에 쌓이며, 메서드 실행이 끝나면 프레임이 사라지면서 메모리가 자동으로 해제됨
* 힙(Heap)영역 : 객체들 존재
  * 객체 멤버 = 인스턴스 멤버
  * 기본적으로 모든 참조타입 객체가 힙영역에 저장됨
  * 객체와 배열이 저장되는 공간으로, JVM에 의해 동적으로 메모리가 할당됨
  * 모든 참조 타입 객체는 힙에 저장되며, 해당 객체의 참조가 스택에 저장됨
  * 힙 메모리는 자동 해제되지 않으며, Garbage Collector가 참조되지 않는 객체를 주기적으로 제거하여 메모리 누수를 방지

Java: Java는 기본적으로 모든 참조 타입 객체가 힙(heap) 영역에 저장되고, 변수는 **스택(stack)**에 해당 객체의 참조(주소)만을 저장한다. 기본 데이터 타입(int, double 등)은 **스택(stack)**에 직접 저장된다.

* 기본 타입 변수: int, double, boolean 등과 같은 기본 데이터 타입은 스택에 직접 저장
* 참조 타입 변수: String, Array, Object 등과 같은 참조 타입 변수는 스택에 객체의 메모리 주소(참조)를 저장하며, 실제 객체는 힙에 저장

스택은 메모리를 자동으로 관리하며, 스택 영역의 변수는 스코프를 벗어나면 자동으로 제거됩니다.

정리하자면
* 기본 타입: 스택에 값 자체가 저장됨.
* 참조 타입: 스택에 객체의 참조(메모리 주소)가 저장되고, 실제 객체는 힙에 저장됨.
* 자동 메모리 관리: Java는 Garbage Collection을 통해 힙 메모리를 자동으로 관리함.

### 1.2 Go의 변수 저장 방식
Go 언어에서 메모리는 크게 **스택(stack)**, **힙(heap)**, **데이터(data)**, 그리고 **코드(code)** 영역으로 나눌 수 있다.

* 스택(stack) 영역
  * 함수 호출 시 생성되는 일시적인 메모리 공간으로, 주로 **지역 변수**나 **함수 호출** 정보를 저장
  * 함수 내부에서 선언된 지역 변수, 값 타입(정수, 실수 등), 구조체 등 **함수 내부에서만 사용되는 변수**가 주로 스택에 할당
* 힙(heap) 영역
    * 프로그램이 실행되는 동안 동적으로 할당되는 메모리 영역
    * 스택과 달리 **할당과 해제가 개발자가 직접 관리되지 않으며**, Go의 **Garbage Collector(GC)**가 메모리를 관리
    * 함수 호출이 종료되어도 변수에 대한 참조가 남아 있으면 메모리가 유지됨 -> 따라서 **오래 생존해야 하는 데이터**나 함수 외부에서도 사용되는 변수는 힙에 할당됨
    * 포인터를 통해 접근하는 변수나, 다른 함수에 의해 참조될 가능성이 있는 값 등은 Escape Analysis를 통해 힙에 할당됨
* 데이터(data) 영역 (java의 static 같은...)
  * **전역 변수**와 **정적 변수**를 저장하는 메모리 공간
  * 프로그램 시작 시 할당되고 프로그램이 종료될 때까지 유지
  * **초기화된 데이터 영역**, **초기화되지 않은 데이터 영역(BSS)**(명시적으로 초기화되지 않은 전역 변수와 정적 변수) 로 나뉨
* 코드(code) 영역
  * **프로그램의 코드(명령어)**가 저장되는 메모리 공간
  * 프로그램에 포함된 모든 함수와 메서드의 코드가 이 영역에 저장 -> 프로그램 실행 도중 변하지 않을 애들

Go의 메모리 관리 기법: Escape Analysis와 Garbage Collection
* **Escape Analysis**: 컴파일러가 변수가 함수 외부로 도달하는지 분석하여, 필요한 경우 힙에 할당하고 그렇지 않은 경우 스택에 할당
* **Garbage Collection**: 힙에 할당된 메모리를 주기적으로 검사하여, 참조되지 않는 객체를 자동으로 해제함으로써 메모리 누수를 방지


Go에서도 기본적으로 지역 변수는 **스택(stack)**에 저장되고, 필요한 경우에만 **힙(heap)**에 할당된다. Go는 Escape Analysis라는 기법을 사용하여 변수의 사용 범위를 분석하고, 프로그램의 성능을 고려하여 스택과 힙을 자동으로 결정한다.

Go와 Java는 각각 메모리 관리 방식을 다르게 설계하여 성능과 안정성을 최적화합니다. 이 두 언어의 메모리 영역에는 몇 가지 공통점이 있지만, 메모리 할당 방식, Garbage Collection, 그리고 메모리 관리 방식에서 차이가 있습니다. 아래에서 Go와 Java의 메모리 영역의 차이를 자세히 설명하겠습니다.

### 요약

| 메모리 영역 | Go  | Java  |
|:----------|:-----|:--------|
| 스택 | 지역 변수와 함수 호출 정보 저장  | 기본 타입과 메서드 호출 정보 저장 |
| 힙 | Escape Analysis를 통해 필요한 경우에만 할당 | 모든 객체와 배열이 힙에 할당 |
| 데이터 | 전역 변수 및 정적 변수 저장 | JVM에서 힙과 메소드 영역으로 분리 관리  |
| 코드/메소드 | 코드만 저장  | 클래스 정보, 메서드, 정적 변수 등을 저장 |
| GC   | 짧은 지연 시간을 위한 동시성 GC 최적화   | 다양한 GC 알고리즘 지원, 힙을 세대별 관리 |


* Go는 가볍고 효율적인 메모리 관리를 위해 Escape Analysis와 짧은 지연 시간의 GC에 초점을 맞췄고, Java는 모든 객체를 힙에 저장하여 일관된 메모리 관리와 다양한 GC 옵션을 통해 유연한 메모리 관리를 제공

## 2. 포인터의 개념
> 메모리 주소를 저장하는 변수
다른 변수나 객체의 위치를 가리킨다. 포인터를 사용하면 직접 메모리 주소를 조작할 수 있으므로, 효율적인 메모리 사용과 성능 최적화가 가능하다.

## 3. Go의 포인터
Go는 포인터를 직접 지원하며, 특정 변수의 메모리 주소를 직접 다룰 수 있습니다. Go의 포인터는 C언어의 포인터와 유사하지만, 더 안전한 방식으로 구현되었습니다.

* 포인터 지원: Go에서는 포인터 타입(*int, *string 등)을 통해 변수의 메모리 주소를 가리킬 수 있습니다. 변수 앞에 & 연산자를 사용해 변수의 주소를 가져올 수 있고, 포인터에 *를 붙여 해당 주소에 저장된 값을 읽거나 수정할 수 있습니다.
* 메모리 안전성: Go는 C언어와 달리 포인터 산술 연산(예: 포인터 값에 정수를 더하거나 빼는 연산)을 지원하지 않아, 메모리 안전성을 유지합니다.
* Garbage Collection: Go의 Garbage Collector는 Java와 마찬가지로 포인터가 가리키는 메모리를 자동으로 관리합니다.

## 4. Java에 포인터가 없는 이유
> Java는 직접적인 포인터를 지원하지 않는다

Java에서 모든 객체는 힙에 저장되고, 객체를 가리키는 **참조(Reference)**를 통해 접근할 수 있다. 이 참조는 포인터와 비슷하게 보이지만, 직접적인 메모리 주소를 다루지 않도록 제한한다.

* 참조 타입: Java에서 객체 변수는 그 객체를 가리키는 참조 타입으로 선언. 하지만, 참조는 메모리 주소를 직접 조작할 수 없는 고수준의 개념
* 메모리 안전성: Java는 참조를 통한 직접적인 주소 접근을 차단하여 메모리 접근을 안전하게 제한. 덕분에 Java 프로그램에서는 메모리 누수나 보안 취약점을 방지
* Garbage Collection: Java는 Garbage Collector가 참조되지 않는 객체를 자동으로 수거하므로, 개발자가 메모리 관리에 신경 쓰지 않아도 된다는 장점