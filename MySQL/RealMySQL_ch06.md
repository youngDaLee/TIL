# Real MySQL - ch06 실행 계획
## 6.1 개요
`Explain` 이나 `desc` 로 확인 가능
- 옵티마이저 : DBMS의 쿼리 실행계획을 수립. 가장 복잡한 부분으로 알려져있음.

옵티마이저의 실행 계획을 알아내야만 실행 계획의 불합리한 부분을 알아내고 최적화 할 수 있음.
### 6.1.1 쿼리 실행 절차
1. 사용자로부터 요청된 SQL문을 잘개 쪼개서 MySQL 서버가 이해할 수 있게 분리
   - 이 단계를 "SQL 파싱(parsing)" 이라 함
   - SQL **신텍스 에러가** 여기에서 걸러짐
   - SQL 파스트리 생성됨(MySQL 서버는 SQL 자체가 아닌 SQL 파스트리로 쿼리 실행함)
2. SQL 파싱정보(파스트리)를 확인해 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
   - 최적화 및 계획수립 단계
   - MySQL 서버 "옵티마이저"에서 처리
   - 실행계획 만든다.
   - SQL 파스트리로 아래 내용 처리
     - 불필요한 조건 제거, 복잡한 연산 단순화
     - 여러 테이블 조인 있는 경우 어떤 순서로 테이블 읽을지 결정
     - 각 테이블 조건과 인덱스 통계 정보 이용해 사용할 인덱스 결정
     - 가져온 레코드들을 임시 테이블에 넣고 다시 가공해야 하는지 결정
3. 결정된 테이블의 읽기 순서 or 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터 가져옴
    - 2단계에서 만든 실행계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
    - MySQL 엔진에서 스토리지 엔진으로부터 받은 레코드 조인하거나 정렬하는 작업 수행

1, 2번 단계는 MySQL 엔진에서 처리, 3번단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리함


### 6.1.2 옵티마이저 종류
옵티마이저는 DB서버에서 두뇌 역할
- 비용 기반 최적화(Cost-based optimizer, CBO) : 현재 대부분의 DBMS가 선택
  - 쿼리 처리하기 위한 여러 가능한 방법 만들고,각 단위 작업 비용 정보와, 대상 테이블 통계정보로 각 실행계획 산출 -> 최소비용 처리방식 선택해 최종쿼리 실행
- 규칙 기반 최적화(Rule-based optimizer, RBO) : 예전 오라클에서 많이 사용
  - 옵티마이저 내장 우선순위에 따라 실행 계획 수립.
  - 통계 정보(테이블 레코드 건수, 컬럼값 분포도) 조사x -> 같은 쿼리에 대해 같은 실행방법 도출

이런게 있다 생각하는 정도. 실행 순서를 결정하는 부분. 옵티마이저의 우선순위가 무엇인지. 어떻게 실행할지.


### 6.1.3 통계 정보
- 통계정보가 명확해야 올바른 방향으로 쿼리 실행함
- MySQL에서의 통계정보는 대량의 레코드 건수와 인덱스의 유니크한 값의 개수 정도.
- 오라클과 같은 DBMS에서는 통계 정보 수집에 많은 시간 소요되어 통계 정보만 따로 백업함.
- MySQL 통계정보는 사용자가 알아채지 못하는 순간 변경되어 동적인 편. 
- 레코드 건수 많지 않으면 통계 정보 부정확한 경우 많아 `ANALYZE` 명령으로 통게 정보 갱신해야 함.

카탈로그 매니저?
- 테이블 마다 용량을 확인해야 하는 상황에 참조하는 상황에.
- information_schema
- index_stats : zmap schema 엄청 많은데 PK 변경한걸 다 확인 할 수 없으니까 MySQL 자체 통계 정보 보면서 PK 정보 확인 할 수 있음.


## 6.2 실행 계획 분석
`EXPLAIN` : 쿼리 실행 계획 확인 가능
- 확인하고 싶은 쿼리 문장 적으면 됨.
- UPDATE, DELETE, INSERT는 지원 안하니까 얘네 확인하고 싶으면 WHERE절만 SELECT에 떼서 확인해라

```SQL
EXPLAIN
SELECT point_name
FROM walkdb.walkingtrails
WHERE region='은평구'
LIMIT 10;
```
![explain](../.img/mysql/realmysql_ch06_1.PNG)
- 표 형태로 된 1줄 이상의 결과 표시됨
### 6.2.1 id 칼럼
**단위(SELECT) 쿼리** : SELECT 키워드 단위로 구분한 것
- !id 컬럼은 단위쿼리별로 값이 부과됨!
- ID가 같으면 같은 쿼리에 속해있다 판단해도 됨.

- 하나의 SELECT 문장 안에서 여러 테이블 조인하면, 조인하는 테이블 개수만큼 실행계획 레코드 출력되지만, 같은 id가 부여됨.
- SELECT 문장은 하나인데 여러 테이블 조인되는 경우는 id값증가하지 않고 같은 id 부여됨

![id](../.img/mysql/realmysql_ch06_2.PNG)

![id2](../.img/mysql/realmysql_ch06_3.PNG)

### 6.2.2 select_type 칼럼
각 SELECT 쿼리가 어떤 타입의 쿼리인지 표시. 수행속도에 절대적인건 아님. 어떻게 실행되고 있냐~ 이정도만 확인하는거고 얘로 튜닝하지는 않음
- SIMPLE
  - UNION이나 서브쿼리 사용하지 않는 단순 SELECT인 경우
  - 실행계획에서 select_type이 SIMPLE인 경우는 반드시 하나만 존재함
- PRIMARY
  - UNION이나 서브쿼리 포함된 SELECT쿼리 실행계획에서 가장 바깥쪽(OUTER)에 있는 단위쿼리
  - 실행계획에서 select_type이 PRIMARY인 경우는 반드시 하나만 존재함
- UNION
  - UNION으로 결합하는 쿼리 중 첫번째를 제외한 **두번째 이후 단위**
  - 첫번째 단위는 UNION 쿼리로 결합된 전체 집합의 select_type이 표시됨
- DEPENDENT UNION
  - UNION이나 UNION ALL이 외부에 형향에 의해 영향을 받는 것.
  - UNION 쿼리 외부의 테이블 컬럼을 참조하는 등...
  - +) 하나의 단위(SELECT) 쿼리가 다른 단위 쿼리를 포함하고 있으면, 이를 서브쿼리라고 함. 서브쿼리가 사용된 경우 외부쿼리보다 서브쿼리가 먼저 실행됨. 다만 select_type DEPENDENT 키워드 포함하면 외부에 의존적이라 외부쿼리보다 서브쿼리가 먼저 실행될 수 없음. => DEPENDENT select_query는 비효율적인 경우가 많음
- UNION RESULT
  - UNION 결과 담아두는 테이블
  - 별도 ID값 부여 X(단위 쿼리 아니라서)
- SUBQUERY
  - FROM절 이외에서 사용되는 서브쿼리 -> 쿼리를 실행하는 동안 임시로 테이블을 생성해두는것이기 때문에(스토리지 엔진에 없음)
  - 서브쿼리는 사용되는 위치에 따라 다른 이름
    - NESTED QUERY : SELECT되는 컬럼에 사용된 서브쿼리
    - SUBQUERY : WHERE절에 사용된 경우
    - DERIVED : FROM절에 사용된 서브쿼리(MySQL에서는 파생테이블이라 함). Inline View 혹은 SubSelect
    - SCALAR SUBQUERY : 하나의 값만(컬럼 1개인 레코드 1개) 반환하는 쿼리
    - ROW SUBQUERY : 컬럼 개수 관계 없이 하나의 레코드 반환하는 쿼리
- DEPENDENT SUBQUERY
  - 서브쿼리가 바깥쪽 select 쿼리에서 정의된 컬럼을 사용하는 경우 -> 외부쿼리가 수행된 뒤 내부쿼리 수행되어야 하기 때문에 느린 경우 다수
- DERIVED
  - FROM절에 사용되는 서브쿼리
  - 단위SELECT 쿼리 실행결과를 메모리나 디스크에 임시테이블 생성함
  - 대부분 DERIVED 형태 실행계획을 조인으로 해결할 수 있도록 변경함
- UNCACHEABLE SUBQUERY
- UNCACHEABLE UNION
### 6.2.3 table 칼럼
MySQL 실행계획은 SELECT 쿼리 기준이 아닌 테이블 기준으로 표시됨. 테이블 별칭이 부과된 경우 별칭이 표시됨. 별도 테이블 사용하지않는 SELECT 쿼리의 경우 table NULL.

`<>` 로 둘러싸인 이름은 **임시테이블**. 표시되는 숫자는 단위SELECT쿼리의 id 지칭
### 6.2.4 type 칼럼
MySQL 각 테이블 레코드를 어떤 방식으로 읽었는지를 의미. -> 인덱스로 레코드를 읽었는지, 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 레코드를 읽었는지. **각 테이블 접근 방식(Access type)** -> 제일 중요함. 어떤 방식으로 테이블을 읽었는지. 어떤 인덱스를 참조하는지, 풀스캔 타는지. ALL이 테이블 전체 다 읽는거라 제일 느림
- system
  - 레코드가 1건 이하인 테이블을 참조하는 형태의 접근 방법
  - InnoDB 테이블에서는 나타나지 않고 MyISAM이나 MEMORY테이블에서만 나타남(InnoDB에서는 index로 표시될 가능성이 큼)
- const
  - 쿼리가 프라이머리키나 유니크 키 컬럼을 이용하는 WHERE 조건절 가지고 있으면서 반드시 1건 반환
  - PK 여러개면 여러 개 다 해야 함(3개면 3개 해야 CONST)
- eq_ref
  - 여러 테이블이 조인되는 쿼리의 실행계획에서만 표시됨
  - 조인에서 처음 읽은 테이블의 컬럼 값을, 그 다음에 읽어야 할 테이블에 프라이머리키나 유니크키 컬럼 검색조건에 사용하면 eq_ref
    - 첫번째 컬럼 값을 다음 테이블의 PK, UK에 사용
    - 순서만 바뀌는게 아니라 eq_ref 조건에 충족해야 하기 때문에
  - 조인에서 두번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 함
- ref
  - eq_ref와 다르게 조인 순서 관계없이 사용. 프라이머리나 유니크 키 제약조건도 없음
  - 동등조건으로만 비교됨
  - const, eq_ref가 아닌데 WHERE절에 동등비교연산자 들어가면 ref
- fulltext
  - MySQL 전문검색 인덱스로 레코드 읽는 접근방법
  - fulltext보다 명확이 빠른 const, eq_ref, ref접근방식 사용가능한 쿼리에서는 fulltext 선택 x.. 그러나 거의 매번 fulltext 사용
  - fulltext에서는 각 조건별 성능 확인해봐야 함
- ref_or_null
  - ref와 같은데 NULL 비교가 추가된 방식
- unique_subquery
  - WHERE조건절에서 사용될 수 있는 IN(subquery)형태의 쿼리를 위한 접근방식
  - 서브쿼리에서 중복되지 않은 유니크한 값만 반환될 때
- index_subquery => 이해가 잘 안됨..
  - subquery가 중복된 값 반환할 수 있지만, 중복된 값을 인덱스로 제거 가능할 때
- **range**
  - 인덱스 레인지 스캔 형태
    - <, >, IS NULL, BEWEEN, IN, LIKE
  - 빠르고 어느정도 성능 보장됨
  - 가장 많이 보게 됨
  - 데이터를 넣으면 PK가 따로 저장됨~! 그래서 PK값을 따로 저장함. PK로 색인하면 엄청 빠름. 테이블 용량도 PK도 많이 차지함.
  - 인덱스는 우리가 지정한거 : 값은 저장하지 않고. 우리가 지정한거. 규모는 작은데. 어느정도는 빠르다. -> 인덱스 값을 따로 저장하고 있어서 인덱스를 너무 많이 저장하면 테이블 용량이 엄청나게 커짐. 오히려 느려질 수 있음. 인덱싱을 잘 해놔야 함. 일반적으로 모든 테이블에 인덱스를 지정하지는 않는데, 검색을 자주 하는 테이블이나, 수정 날짜 기준으로 하는.. 기간으로 보여주는 데이터는 인덱스가 걸려있음(조회할 때 빠르니까).
    - 컬럼이 인덱스로 잡혀있으면, 인덱스로 검색할 수 있게 되고, RANGE로 검색됨. -> 인덱스 지정 안하면 ALL로 됨(개오래걸림) 
- index_merge
  - 2개 이상의 인덱스를 이용해 각 검색결과를 만든 후 그 결과를 병합하는 처리방식
  - 여러 인덱스를 읽어야 해서 range보다 효율 떨어짐
  - AND, OR 연산 복잡할딴 최적화 x..
  - 전문검색 인덱스 사용하면 index_merge 적용 x
- index
  - 인덱스를 처음부터 끝까지 읽는 인덱스 풀스캔
  - 플테이블스캔보다는 빠르지만 그닥 효육적이지는 않음
  - 아래 경우 주로 사용됨
    - range, const, ref 사용 불가
    - 인덱스에 포함된 커럼만으로 처리할 수 있는 쿼리
    - 인덱스를 이용해 정렬, 그룹핑 가능
  - 인덱스를 풀스캔한다. 인덱스만 풀스캔한다. 풀스캔이라 좋은건 아닌데.. -> 아무 조건 없이 ORDER BY 때린다던가;
- ALL
  - 풀테이블 스캔
  - 가장 비효율적인 스캔
  - ALL 뜨는건 잘못된 쿼리임.
  - 아무 인덱스도 안된걸 WHERE조건에 걸어버리면 7~800G를 그냥 다 읽는거라 거업나 오래걸림.. 좋지 않은 쿼리. => 인덱스를 적절하게 설정하는게 중요. 인덱스 컬럼이 자주 사용되는 컬럼, 데이터가 다양한 컬럼이여야 함. 멤버 번호(고유한 값)... 성별(남/여) 한정적이라 이걸 가지고...
    - 남/여 합쳐서도 나눠서도 검색해야 하는 테이블이면 굳이 정규화 하는것보다는(UNION 성능 구림) 그 앞에 먼저 조건을 걸어야 함 

### 6.2.5 possible_keys
"사용될 법 했던 인덱스 목록"
- 걍 무시하셈

### 6.2.6 key
최종 선택된 실행계획에서 사용되는 인덱스. type이 ALL일때와 같이 인덱스 전혀 사용 못하면 Key컬럼 NULL
- 내가 의도한값으로 잘 탔는지 확인하기
- KEY, INDEX 안잡았으면 걍 NULL

### 6.2.7 key_len
쿼리를 처리하기 위해 다중컬럼으로 만들어진 인덱스가 몇 개의 컬럼까지 사용했는지. 바이트값이 표시됨
- 잘 안봄

### 6.2.8 ref
참조 조건(Equal 비교조건)으로 어떤 값이 제공되었는지. 만약 산수값 지정했으면 ref 컬럼 값 const로 표시, 다른 테이블 컬럼값이면 해당 테이블명과 컬럼명 표시.
- func로 표시되는 경우 : 콜레이션 변환값이나 값 자체의 연산을 거쳐 참조되었다는 것을 의미함

### 6.2.9 rows
레코드 건수. 반환되는 레코드 건수가 아닌 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지 의미함. 오차 심함
- 작으면 작을수록 좋음.

### 6.2.10 Extra -> 여러 번 다시 보면서 질문 정리하기
쿼리 실행계획에서 성능에 관련된 중요한 내용이 Extra컬럼에 표시됨.    
많이 봄. 중요한 부분 -> 다 외울 필요는 없음
- const row not found
  - const방식으로 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을 때
- Distinct
  - 조인하지 않아도 되는 항목은 무시하고 필요한것만 조회했으며, 필요한 레코드만 읽었다
  - Distinct 처리했을 때
- Full scan on NULL key
  - 컬림이 NULL이면 풀테이블스캔 해야만 결과 알아낼 수 있음(NOT NULL 컬럼이면 이 표시 무시해도 됨)
  - 서브쿼리가 1건이라도 결과레코드 가지면 최종비교 결과가 NULL, 1건도 가지지 않으면 FALSE
- Impossible HAVING
  - HAVING절을 만족하는 레코드 없을 때
  - 쿼리가 제대로 작성하지 못한 경우
- Impossible WHERE
  - WHRER 조건이 항상 FALSE인 경우
- Impossivle WHERE noticed after reading const tables
  - 옵티마이저 실행계획 단계에서 쿼리 일부 수행
- No matching min/max row
  - 쿼리의 WHERE 조건절 만족하지 못하는 경우 중 `MIN()`,`MAX()` 결과가 한 건도 없는 경우 
- No matching row in const table
  - 조인테이블에서 const방식으로 접근할 때 일치하는 레코드가 없는 경우
- No tables used
  - FROM절에 상수테이블(CUAL)이 사용될 때
- Not exist
  - A테이블에 존재하지만 B테이블에 존재하지 않는 데이터 조회 시 NOT IN 이나 NOT EXIST 연산자를 사용하는데, 때에 따라 아우터 조인(LEFT OUTER JOIN)으로 구현 가능함. 이때 Not exist 메세지 표시됨
- Range checked for each record (index map: N)
  - 매 레코드마다 인덱스 레인지 스캔을 체크함(어떨땐 풀테이블스캔 사용, 어떨땐 레인지 스캔 사용)
  - Inner 조인 많이 쓰고,
  - 얘가 나오면 일종의 중첩포문..
- Scanned N databases
  - N개의 DB정보를 읽었는지 보여주는 것
    - 0 : 특정 테이블에 정보만 요청되어 DB 전체 메타정보 읽지 않음
    - 1 : 특정 DB 내 모든 스키마 정보 요청되어 해당 DB 모든 스키마 정보 읽음
    - All : MySQL 서버 내 모든 스키마 정보 다 읽음
  - Info Schme에서 DB 통게 정보가사용됨. InFO DB 읽었을 때.. 얘 나옴
- Select tables optimized away
  - `MIN()` `MAX()` 조회 쿼리가 적절한 인덱스를 사용할 수 없을 때 인덱스를 오름차순/내림차순 정렬해 1건만 읽는 형태의 최적화 적용됨
- Skip_open_table, Open frm_only, Open_trigger_only, Open_full_table
  - INFORMATIONS_SCHEMA DB의 메타정보 조회하는 SELECT 쿼리 실행계획에서만 표시되는 내용
  - Skip_open_table : 테이블 메타정보가 저장된 파일을 별도로 읽을 필요 없음
  - Open frm_only : 테이블 메타정보 저장된 파일(*.FRM)만 읽음
  - Open_trigger_only : 트리거 정보 저장된 파일(*.TRG)만 읽음
  - Open_full_table : 최적화 되지 못해 위 메타정보파일(*.FRM), 데이터( *.TRG), 인덱스 파일( *.MYI)까지 다 읽음
- unique row not found
  - 두 테이블이 각각 유니크/프라이머리 컬럼으로 아우터 조인 수행하는 쿼리에서, 아우터 테이블에 일치하는 레코드 없을 때
- Using filesort
  - ORDER BY 처리가 인덱스를 사용 못할 때
  - 안좋음!!!! 인덱스 튜닝 필요!! 
- Using index(커버링 인덱스)
  - 데이터 파일 전혀 읽지 않고 인덱스만 읽어서 쿼리 처리 가능할 때
  - 접근 방식이 eq_ref, ref, range, index_merge, index 등과 같이 인덱스 사용하는 실행계획에서는 모두 Using Index 표시 가능
- Using index for group-by
  - GROUP BY 연산 처리 위해 MySQL은 그룹핑 기준 칼럼으로 정렬 수행 -> 정렬된 결과 그룹핑하는 고부하작업 수행. 
  - GROUP BY 처리가 인덱스(B-TREE 한해) 이용하면 정렬된 인덱스 컬럼을 순서대로 읽으면서 그룹핑 처리.
    - 레코드 정렬 없이 인덱스만 읽으면 되기 때문에 효율적
  - GROUP BY처리가 인덱스를 이용할 때
  - 루스 인덱스 스캔 -> 필요한 부분만 듬성듬성읽음
  - WHERE절에서 사용하는 인덱스에 의해서도 사용 여부 영향받음
- Using join buffer
  - 드리븐 테이블에 인덱스가 없으면 매번 풀스캔 해야 함. -> 비효율적...
  - 이를 보완하가 위해 드라이빙 테이블에서 읽은 레코드를 임시공간(조인 버퍼)에 보관해둠.
  - 조인 버퍼가 사용될 때 Using join buffer 표시됨
- Using sort_union(...), Using union(...), Using intersect(...)
  - 쿼리가 index_merge 방식으로 실행되면, 2개 이상 인덱스가 동시 사용됨. -> EXTRA에서 두 인덱스 결과 어떻게 병합했는지 아래 3가지로 설명
  - Using intersect(...)
    - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된경우, 각 처리 결과에서 교집합을 추출해내는 작업을 수행함
    - Using union과 같은 작업 수행하지만 Using union으로 처리 불가능(OR로 연결된 대량의 range 조건들)
    - 프라이머리 키만 먼저 읽어서 정렬, 병합 후 레코드 읽어 반환 가능
  - Using union(...)
    - 각각의 인덱스를 사용할 수 있는 조건이 OR로 연결된경우, 각 처리 결과에서 합집합을 추출해내는 작업을 수행함
  - Using sort_union(...)
    - Using union과 같은 작업을 수행하지만, Using union으로 처리 불가능한 경우(OR로 연결된 대량은 range 조건)
    - PK만 먼저 읽어 정렬, 병합 후 레코드를 읽어 반환
    - using union과 using sort_union은 정렬알고리즘의 싱글패스 정렬알고리즘/투패스 정렬알고리즘 차이와 같음
- Using temporary
  - MySQL 쿼리 처리하는 동안 중간 결과를 임시테이블에 저장.
  - Using temporary : 임시테이블 사용한다~(GROUP BY ... )
    - => 그 FROM 절 내 UNION연산같은 경우도 Using temporary 나오는지?
  - MySQL 처리 중 임시테이블 사용
  - 임시테이블이 메모리에 저장되었는지 디스크에 저장되었는지는 알 수 없음
- Using where
  - MySQL 엔진 레이어에서 별도 가공 해서 필터링 작업 한 경우
  - MySQL은 내부적으로 크게 MySQL 엔진/스토리지 엔진 레이어로 나뉨.
  - MySQL엔진은 스토리지 엔진으로부터 받은 레코드를 가공or연산하는 작업을 수행
  - MySQL엔진레이어에서 별도의 가공 후 필터링 작업 처리 시 Using WHERE 코멘트 표시됨
- Using where with pushed condition
  - coudition push down 적용됨
  - 스토리지 엔진의 비효율이 개선도니 형태

### 6.2.11 EXPLAIN EXTENDED(Filtered 컬럼)
필터링이 얼마나 효율적으로 실행됐는지 알려주기 위해 Filtered 컬럼 추가. 필터링되어 제거된 레코드 제외 최종적으로 레코드가 얼마나 남았는지 퍼센트(%)로 알려줌
- 중요한 부분. 디스크에서 얼마나 갖고 와서.. MySQL엔진에서 얼마나 처리되었는지 알 수 있는 부분

### 6.2.12 EXPLAIN EXTENDED(추가 옵티마이저 정보)
분석된 파스트리 재조합하여 쿼리 문장과 비슷한 순서대로 나열해 보여주는것
- 사용 거의 안함

### 6.2.13 EXPLAIN EXTENDED(Partitions 컬럼)
파티션 테이블 실행 계획 정보 확인. 쿼리를 사용하기 위해 테이블 파티션 중 어떤 파티션 사용했는지 정보 확인함.   
파티션 프루닝(Partition pruning) : 파티션 여러개인 테이블에서 불필요한 파티션 빼고 쿼리 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정
- `EXPLAIN PARTITIONS` 명령으로 참조한 파티션 확인 가능

- 우리는 파티션을 실제로 사용 x zmap 테이블이 파티션처럼 나뉘어만 있음(우리가 수동으로 이벤트를 돌려서 테이블 확인)
- 이벤트 스케줄러가 돌고 있음
  - 수동으로 하느 이유: 파티션을 하면 SELECt 할 때 이슈 발생. -> 서비스에 영향 미침
  - Partition 이점 : 실제로는 나뉘어 있는데 실제로는 하나로 되어있음. 월별로 파티셔닝 하는것도 알아서 하고. 데이터 인서트 할 때도 빠르고... insert/delect 간편. -> select 시간 오래걸림

## 6.3 MySQL의 주요 처리 방식
"풀 테이블 스캔" 을 제외한 모든 스캔은 스토리지 엔진이 아닌 MySQL 엔진에서 처리됨. MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 큰 영향을 미침.

### 6.3.1 풀 테이블 스캔
인덱스를 사용하지 않고 테이블 데이터를 처음부터 끝까지 읽어 처리.
- 생각보다 빨리 일어남. 레코드 건수 작을ㄸ는 오히려 인덱스보다 빠름.     
- WHERE절로 걸러진 데이터가 너어어무 많아서 무의미한 경우는 풀테이블 스캔을 돌아버림.
- ORACLE은 알아서 나눠서 읽어주는데 MySQL은 그런게 없음...
- read a head : 한 번에 일억건씩 가져오는 건 없으니까 페이지네이션해서 가져옴. innodb_read_ahead_threadshold 일정한 풀스캔이 돈다 innodb에 캐시처럼 저장되는거
- 풀스캔 범위를 잘못 잡으면 며칠씩 걸린다~!!

**풀스캔을 사용하는 경우**
- 테이블 레코드 건수가 아주 작은 경우(인덱스보다 풀스캔이 빠름)
- WHERE절이나 OR절에 인덱스 적절히 사용할 수 없는 경우
- 인덱스 스캔 할 수 있어도 일치 레코드 건수가 너무 많은 경우

### 6.3.2 ORDER BY 처리(Using filesort)
- 레코드 1~2건을 가져오는 쿼리 제외하면 대부분 정렬이 필수(대량으로 불러오는 DW 제외하면...)
- 정렬 위한 방법
  - 인덱스 이용
    - Insert, Update, Delete 시 이미 인덱스 정렬되어있어서 **빠름**
    - Insert, Update, Delete 시 부가적 인덱스 추가/삭제 작업 필요해서 느림. 인덱스 공간 소모. 늘어날수록 InnoDB 버퍼풀 or MyISAM 키 캐시용 메모리 많이 필요
  - 쿼리 실행 시 "Filesort" 처리
    - 인덱스 사용하지 않아서 메모리 효율. 정렬해야 할 레코드 많지 않으면 메모리에서 Filesort처리되어서 빠름
    - 레코드 건수 많아질수록 느림
  - 인덱스로 정렬 튜닝 불가능한 경우
    - 정렬 기준 너무 많아서 모든 인덱스 생성 불가능 할 때
    - Group By결과 or DISTINCT 처리 정렬
    - UNION 같이 임시테이블 정렬
    - 랜덤 레코드 가져와야 하는 경우

인덱스 사용하지 않고 별도 정렬처리 했는지는 실행계획 Extra 컬럼에서 확인 가능(Using filesort)    

쿼리 실행 시 Filesort vs 인덱스로 정렬 튜닝 불가능
- 어떤 경우에 filsort / 인덱스 정렬 튜닝 불가능
- filesort : 소트버퍼에서 정렬 가능
- 인덱스 정렬 튜닝 불가능 : 소트버퍼에서도 안됨. 디스크사용.


**소트 버퍼(Sort buffer)**
- 정렬 수행하기 위한 별도의 메모리 공간
- 정렬할 레코드가 극소량이어서 할당도니 소트버퍼만으로 정렬할 수 있으면 빠르게 처리 가능
- 레코드 건수가 소트버퍼보다 크면, 쪼개놓은 정렬할 레코드를 디스트에 저장함 -> 버퍼에 정렬, 디스크에 임시저장 반복..(멀티머지(Multi-merge)) 수행한 멀티머지 횟수가 Sort_merge_passes 라는 상태변수에 누적됨
- 소트버퍼를 크게 설정해도 별 차이 없음.
- 56KB ~ 1MB 적절
- 여러 클라이언트가 공유할 수 있는 공가니이 아님. 커넥션이 많을수록 소트버퍼로 소비되는 메모리공간 커짐. -> 메모리 부족 현상 -> OOM-Killer가 메모리 확보 위해 프로세스 강제 종료


**정렬 알고리즘**
- 싱글패스 알고리즘
  - 정렬기준 컬럼 포함해 SELECT 컬럼 전부 담아 정렬 수행
  - 더 많은 소트버퍼공간 필요
```sql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```
- 투패스 알고리즘
  - 정렬 대상 컬럼과 프라이머리키값만 소프버퍼에 담아 정렬 수행.
  - 정렬 순서대로 다시 프라이머리키로 테이블 읽어 SELECT할 컬럼 가져오는 알고리즘
  - 5.x이전 버전 MySQL 에서 사용
  - 같은 레코드 두 번 읽어야해서 불합리.
- 일반적으로 싱글패스
- 투패스는 ㅔ이블 두 번 읽어야해서 불합리
- 싱글 : 레코드 적은 경우 빠르고 / 투패스 : 많으면 효율적염

**정렬 처리 방식**
- 인덱스 사용한 정렬
  - Extra 코멘트 : 별도 표기 x
  - ORDER BY 순서대로 인덱스가 있어야 함. => 인덱스 생성을 할 때도 어떤게 우선순위로 있어야 하는지 고려해야 함. Orderby 바뀌면 아예 인덱스를 못탐
  - 이미 정렬되어있기 때문에 별도 정렬 X 다만 ORDER BY 명시하지 않으면 기대했던 순서대로 쿼리 가져오지 못할 수 있음 -> 어차피 작업량 늘지 않으니 그냥 명시해두는게 좋음
- 드라이빙 테이블만 정렬(조인 없는 경우 포함)
  - Extra 코멘트 : Using filesort
  - 일반적으로 조인 수행되면 결과 레코드 건수가 몇 배로 불어남. 따라서 조인 전 첫번째 테이블의 레코드를 먼저 정렬한 뒤, 조인을 실행하는게 차선책임
- 조인 결과를 임시테이블로 저장 후 임시테이블에서 정렬
  - Extra 코멘트 : Using temporary;Using filesort
  - 2ㅐ 이상의 테이블을 조인해서 결과를 정렬해야 하면 임시테이블이 필요할 수도 있음


**드라이빙 테이블 & 드리븐 테이블**
- 드라이빙 테이블 : JOIN 시 먼저 액세스 되는 쪽
- 드리븐 테이블 : JOIN 시 나중에 액세스 되는 테이블
- 조인 시 작업 대상 행(row)이 적은 테이블부터 액세스 되어야(드라이빙 테이블) 전체 탐색 줄어든다
- 드라이빙, 드리븐 테이블은 옵티마이저에서 결정
  - 인덱스를 사용항 액세스 방식이 풀테이블 액세스보다 우선순위 높음
  - 조인컬럼에 대한 인덱스가 양쪽 테이블에 있을 때 -> 우선순위가 높은 테이블 선택
  - 조인칼럼에만 인덱스가 존재하는 경우에는 인덱스가 없는 테이블 먼저 선택해 조인 수행
  - 조인 테이블 우선순우 ㅣ동일하지 않으면 FROM절에 나열된 순서대로 조인 수행

- 둘 다 인덱스가 있는 경우
  - 옵티마이저 판단으로 각 테이블 레코드 수에 따라 드라이빙/드리분 결정
- 한쪽에만 인덱스 있는 경우
  - **인덱스 없는 테이블이 드라이빙** 테이블
  - 드리븐 테이블이 드라이빙 테이블만큼 풀스캔 되어야 하기 때문
- 둘 다 인덱스 없는 경우
  - 어떤 쪽도 드리븐 풀스캔 발생
  - 스캔되는 레코드 수에 따라 드라이빙 테이블 선택


**정렬방식 성능 비교**
- 스트리밍 방식
  - 서버쪽에서 처리해야 할 데이터 얼마나 되는지 관계 없이 조건 일치하는 레코드 검색될때마다 클라이언트로 전송
  - 첫번째는 바로 받지만 마지막은 언제 박을지 미지수
  - LIMIT으로 성능 향상
- 버퍼링 방식
  - 결과를 모아서 일괄로 제공
  - LIMIT 제한 걸어도 성능 향상 x


**정렬 관련 상태 변수**
- sort_merge_passes  :멀티 머지 처리 횟수
- sort_range : 인덱스 레인지 스캔을 통해 검색도니 결과에 대한 정렬 횟수
- sort_rows : 지금까지 정렬한 전체 레코드 건수
- sort_scan : 풀테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수

### 6.3.3 GROUP BY 처리
HAVING절 사용 가능 -> GROUP BY절 결과에 대해 필터링 역할 수행.   
GROUP BY에 사용된 조건은 인덱스로 처리될 수 없으니까 HAVING절로 튜닝하려고 인덱스 생성할 필요 없음.    
GROUP BY도 인덱스 사용하는 작업(인덱스 스캔)/아닌 작업(루스 인덱스 스캔. 임시테이블 사용)으로 나뉨.    


**인덱스 스캔 사용하는 GROUP BY(타이트 인덱스 스캔)**
- 인덱스로 읽으므로 추가적인 정렬 필요 X
- 다른 EXTRA 컬럼 코멘트 표시 X


**루스(loose) 인덱스 스캔을 이용하는 GROUP BY**
- 인덱스 레코드 건너뛰면서 필요한 부분만 가져오는 것
- 실행계획의 Using index for group-by 코멘트 
- 인덱스 레인지스캔은 분포가 일정할수록 성능 향상 / 루스 인덱스 스캔은 유니크한 값 수가 적을수록 성능 향상(분포도 좋지 않은 인덱스일수록 성능 향상)
- 별도 임시테이블 필요하지 않음
- 평균 내야할 때는 못씀(다 읽어야 하니까)
- 최솟값/최댓값 읽을때는 제일 첫 값만 읽어도 되니까.


**임시테이블 사용하는 GROUP BY**
- GROUP BY 기준 컬럼이 드라이빙이든 드리븐이든 관계 없이 인덱스를 사용하지 못할 때.

### 6.3.4 DISTINCT 
특정 컬럼의 유니크한 값 조회 위해 사용. MIN, MAX, COUNT 등 집합 함수와 함께 사용하는 정우 / 집합함수가 없는 경우로 나뉨. => DISTINCT의 영향 범위가 다름. DISTINCT가 인덱스 사용 못할때는 항상 임시테이블 필요(하지만 extra에는 Using temporary x)

**SELECT DISTINCT**
- SELECT 되는 레코드 중 유니크한 값만을 가져올 때
- GROUP BY와 거의 같은 형식으로 처리
- SELECT DISTINCT같은 경우는 정렬이 보장되지 않음
- 레코드를 유니크하게 SELECT 하는거지, 컬럼을 유니크하게 조회하는게 아님
- DISCTINCT는 함수가 아니라 괄호가 의미있는게 아님(한 컬럼만 유니크하게 가져오지 않음. 모든 컬럼에 영향)

**집합 함수와 함께 사용된 DISTINCT**
- COUNT(), MIN(), MAX() 같은 집합 함수에서 DISTICT 사용됨 -> 이 경우 SELECT DISTINCT와 다른 형태로 해석됨
- SELECT 쿼리에서는 조회하는 모든 컬럼의 조합이 유니크한 것 가져옴
- 집합합수에서는 컬럼 중 중복 제외하고 남은 값만 가져옴.
- DISTINCT 처리 시 인덱스가 없으면 임시테이블 필요. 다만 인덱스된 컬럼에 대해 DISTINCT 연산 시 풀스캔이나 레인지스캔 없이 최적화된 처리 가능


### 6.3.5 임시테이블
꽤 자주 쓰임!    
MySQL 엔진이 스토리지로부터 받아온 레코드 정렬하거나 그룹핑 할 때 임시테이블 사용함.   
일반적으로 처음에는 메모리에 생성되었다가, 크기가 커지면 디스크로 옮겨감(예외 케이스에서 바로 디스크로 가는 경우 있음).   
스토리지 엔진과 관련 없이 임시테이블이 메모리 사용할 시 MEMORY 스토리지 엔진 사용하고, 디스크 저장 시 MyISAM 스토리지 엔진 사용함

**임시테이블이 필요한 쿼리**
- ORDER BY, GROUP BY에 명시된 컬럼이 다른 쿼리
- ORDER BY, GROUP BY에 명시된 컬럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재할 경우 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type이 UNION RESULT)
- UNION ALL이 사용된 쿼리(select_type이 UNION RESULT)
- 쿼리의 실행계획 select_type이 DERIVED인 쿼리

EXTRA가 Using temporary 표시되면 임시테이블 사용하는거임.
- 아닐수도 있는데, 위 예시의 마지막 3개가 그런 예시임
- 위 예시 1~4는 유니크 인덱스 가지는 임시테이블 / 5~6은 유니크데이스 없는 임시테이블. -> 일반적으로 유니크 인덱스 있는 내부임시테이블이 처리 성능이 느림


**임시테이블이 디스크에 생성되는 경우(MyISAM 스토리지 엔진 사용)**
- 임시테이블에 저장해야 하는 내용 중 BLOB 이나 TEXT 같은 대용량 컬럼 있는 경우
  - TEXT는 잘안씀. VARCHAR 자주 쓰고. TEXT는 꼭 필요할 때. 이 데이터를 무조건 저장해야해. 뉴스키사도 VARCHAR로 커버 가능.
  - RMR에서 스캔 결과가 싸아악다 저장되었던 경우
- 임시테이블에 저장해야하는 전체 크가나 UNION/UNION ALL 에서 SELECT 되는 컬럼 중 길이가 512 바이트 이상 컬럼 존재
- GROUP BY나 DISTINCT 컬럼에서 512 바이트 이상 컬럼 존재
- 임시테이블에 저장할 데이터 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정 값보다 큰 경우
  - 처음에는 MEMORY에 저장, 테이블 크기가 시스템 설정값 넘어가면 디스크의 MyISAM 테이블로 변환


**임시테이블 관련 상태변수**
- created_tmp_tables : 쿼리를 위해 만들어진 내부 임시테이블 개수 쿠적하는 상태값. 모두 누적
- created_tmp_disk_tables : 디스크에 내부 임시테이블이 만들어진 개수만큼 누적해서 가지고 있는 값


**임시테이블 주의사항**
- 레코드 건수 많지 않으면 내부 임시테이블이 메모리에 형성되어 MySQL 서버 부하에 영향 x
- 이슈 : 내부 임시테이블이 MyISAM 테이블로 디스크에 저장되는 겨웅
### 6.3.6 조인
진!!짜 중요!!!! 
#### 조인 종류
- JOIN(INNER JOIN)
  - 어느 테이블 먼저 읽어도 결과 달라지지 않음. -> MySQL 옵티마이저가 조인 순서 결정
  - 데이터 있는 것 끼리 조인.
  - 거의 다 사용. 찐짜찐짜 많이 사용
  - 네스티드-루프 방식만 지원
    - FOR 문 도는 거랑 똑같음.
    - 프로그램 작성 시 두 개의 FOR나 WHILE과 같은 반복루프문장을 실행하는 형태로 조인이 처리됨.
- OUTER JOIN
  - 반드시 OUTER 테이블을 먼저 읽어야 하기 때문에 조인 순서를 옵티마이저가 선택 불가.
  - INNER JOIN과 다르게 버리는 값이 없음. INNER 테이블이 조인 결과에 영향 미치지 않고 OUTER 테이블에 따라 조인 결과 결정됨. OUTER는 버려지지 않음.
  - LEFT OUTER JOIN
    - OUTER 테이블이 왼쪽에 있음
  - RIGTH OUTER JOIN
    - OUTER 테이블이 오른쪽에 있음
  - FULL OUTER JOIN
    - MySQL에서는 지원 X. 왼쪽,오른쪽 둘 다 OUTER 처리하고 싶을때.
    - 다만 LEFT와 RIGHT를 잘 조합해서 FULL OUTER JOIN 구현 가능함
  - MySQL 실행계획에서는 INNER JOIN인지 OUTER JOIN인지 알려주지 않아서 OUTER을 의도한 쿼리가 INNER로 처리되진 않는지 살펴야 함
  - 옵티마이저가 OUTER를 INNER로 변형할 수 있기 때문에 조건을 ON절에 꼭 명시하자. 
- NATURAL JOIN
  - 컬럼의 이름이 동일한 컬럼을 모두 조인
  - `INNER JOIN salaries s ON s.emp_no=e.emp_no` 와 같음
  - INNER JOIN 조건 명시안해도 되는 편리함 -> 각 테이블의 컬럼 이름에 의해 쿼리가 자동으로 변경되는 문제.
  - 유지보수 역효과...
- CROCSS JOIN(FULL JOIN, CARTESIAN JOIN(카데시안 조인))
  - 조인 조건 없이 2개 테이블에서 모든 레코드 조합을 결과로 가져옴
  - 레코드가 1~2건으로 많이 않을때면 문제 없는데, 레코드 건수 많을수록 기하급수적으로 늘어나 MySQL 서버 죽일 수 있음
  - 조인 테이블 많아지고 조인 조건 복잡해질수록 의도치 않은 카데시안 조인 발생 가능성 크다.
  - 이너조인과 문법으로 구분되지 않음. 조건이 적절하면 이너조인으로, 그렇지 않으면 카데시안 조인이 됨.


JOIN 시 ON절, WHERE 절에 조건을 넣는지에 따라 결과가 다름    
FROM절을 제일 먼저 읽고, ON절에 조건 넣으면 ON으로 데이터 거르고 가져오는데... WHERE절에 넣으면 데이터 다 가져오고 가져옴.. 
- Inner vs Outer : 성능 고민말고 상황에 따라 선택
- 1:n 하려면 OUTER 조인 필요한 경우 생김
- 예전에는 성능 구졌는데 지금은 잘 사용.. 
- FULL JOIN, NATURAL JOIN : 사실상 안쓰임.

**Single-sweep multi join**
- 네스티드-루프 조인을 single-swepp multi join 이라고도 함.
- 조인에 참여하는 테이블 개수 만큼 반복 루프가 중첩됨
- 반복 루프를 돌며 레코드 단위로 모든 조인 대상 테이블을 차례대로 읽는 방식.
- 드라이빙 테이블을 읽은 순서대로 레코드가 정렬되어 반환함.
- 조인에서 드리븐 테이블들은 단순히 드라이빙 테이블의 레코드를 읽는 순서대로 검색만 함.

 
**조인 버퍼를 이용한 조인*Using join buffer**
- 드라이븐은 한번에 쭉 읽고 드리븐은 여러번 읽게 됨.
- 드리븐의 풀테이블 스캔을 피할 수 없으면, 옵티마이저가 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 메모리를 조인하는 형식으로 처리함. -> 이 때 사용되는 메모리 캐시를 조인 버퍼(Join buffer)라 함
- 조인 완료되면 조인버퍼 해제됨

**조인 관련 주의사항**
- 조인 실행 결과 정렬 순서
- INNER JOIN, OUTER JOIN 선택



## 6.4 실행 계획 분석 시 주의사항
실행 계획의 컬럼에 표시되는 값 중 주의해서 확인해야 하는 사항
### 6.4.1 Select_type 컬럼 주의 대상
- DERIVED
  - FROM 절에 사용된 서브쿼리로부터 발생한 임시테이블.
  - 임시테이블이 메모리에 저장된 경우는 성능에 영향 미치지 않아 괜찮지만, **디스크**에 저장된 경우 크케 성능에 영향 미침
- UNCACHEABLE SUBQUERY
  - FROM절 이외에서 사용하는 서브쿼리는 최대한 캐싱해서 재사용 유도함.
  - 사용자 변수나 일부 함수 사용된 경우 캐시 사용 불가능
  - 사용자 변수 제거하거나 다른 함수 대체해서 사용 가능한지 검토 필요
  - SET 사용해놓으면 캐싱 / SELECT만 쓰면 캐싱 전혀 안함!
- DEPENDENT SUBQUERY
  - FROM절 이외의 부분에서 사용하는 서브쿼리가 자체적으로 실행되지 못하고 외부 쿼리에서 값을 받아 실행하는 경우
  - 서브쿼리 외부에 의존적이기 때문에 전체적으로 느리게 만듬
  - 외부쿼리 의존도 제거 필요

### 6.4.2 Type 컬럼 주의 대상
- ALL
  - 풀 테이블 스캔
- index
  - 인덱스 풀 스캔
  - 풀스캔보다는 빠르지만... 그렇게 좋은 성능은 아님 다 읽어야 하니까ㅠ
  - 웹서비스 시 풀스캔은 절대 안됨~~!!! DB 커넥션 자체도 시간이 걸리기 때문에 웹서비스에서는 절대안돼!!

둘 다 대상 차이만 있고 전체 레코드 대상 작업방식. OLTP 환경에 적합하지 않음.
- 새로운 인덱스 추가하거나 쿼리 요건 변경해서 해결 필요

### 6.4.3 Key 컬럼 주의 대상
- 쿼리가 인덱스 사용 못할때 key에 아무런 표시 x. -> 적절한 인덱스 추가하거나 WHERE절 조건 변경

### 6.4.4 Rows 컬럼 주의 대상
- 실제 레코드보다 Rows가 훨씬 큰 경우, 쿼리가 인덱스를 정상적으로 사용하고 있는지, 인덱스가 작업 범위를 좁혀줄 수 있는 컬럼으로 구성되어 있는지 확인 필요
  - 효율적이지 않으면 인덱스 재생성 or 쿼리 요건 변경 필요
- Limit 제한은 Rows 컬럼 고려 대상에서 제외됨. LIMIT 1 이더라도 Rows는 훨씬 큰 수치 나오고, 성능상 아무 문제 없는 최적화된 쿼리일 수 있음

### 6.4.5 Extra 컬럼 주의 대상
중요한 내용 많이 표시됨. 기억했다가 자세히 검토 필요
#### 쿼리가 요건을 제대로 반영하고 있는지 확인해야 하는 경우
쿼리가 요건 제대로 반영됐거나 버그 가능성 없는지 확인 필요
- Full scan on NULL key
- Impossible HAVING(MySQL 5.1~)
- Impossible WHERE(MySQL 5.1~)
- Impossible WHERE noticed after reading const tables
- No matching min/max row(MySQL 5.1~)
- No matching row in const table(MySQL 5.1~)
- Unique row not found(MySQL 5.1~)

#### 쿼리의 실행 계획인 좋지 않은 경우
쿼리를 더 최적화 할 수 있는지 검토
- Range checked for each record(index map: N)
- Using filesort
- Using join buffer(MySQL 5.1~)
- Usinhg temporary
- Using where

#### 쿼리의 실행계획이 좋은 경우
최적화되어 처리되고 있는 지표. 특히 두번째 Using index는 커버링 인덱스로 처리되고 있음을 알려줌->MySQL 최고의 성능
- Distinct
- Using index
- Using index for group-by

## 읽기 좋은 블로그
- [데이터베이스 옵티마이저에 대하여](https://coding-factory.tistory.com/743)
- [Optimize Table & Analyze Table](https://myinfrabox.tistory.com/145)
- [InnoDB에 대하여(MyISAM과 차이점)](https://sarc.io/index.php/mariadb/346-innodb-myisam)
- [드라이빙 테이블의 개념/규칙](https://devuna.tistory.com/36)

## QnA
### Q) 옵티마이저를 일종의 컴파일러로 이해해도 되는 것인지

### Q) select_type 컬럼에서 SIMPLE은 왜 하나만 존재함?

### Q) 첫번째 단위는 UNION 쿼리로 결합된 전체 집합의 select_type이 표시됨 -> ?

### Q) 튜닝 시 실제로 실행계획을 참고하는 편인지

### Q) ref는 where절에 동등조건 비교만 있으면 되는건지

### Q) 아래 경우 e.emp_no가 프라이머리나 유니크 키값이 아닐 때, employees가 depth_emp보다 먼저 조인되었으므로 eq_ref라고 판단 불가능 한 것인지
```sql
EXPLAIN
SELECT * FROM employees e, dept_emp de
WHERE e.emp_no=de.emp_no AND de.dept.no='d005'
```

-------
### Q) index 컬럼이면 FULL Scan을 타는건지
  - index와 NULL 허용과는 관련이 없음
  - PK와 index의 차이는 NULL 허용의 차이.

### Q) 340 페이지가 잘 이해가 안됨. ORDER BY 절이 드리븐 테이블이더라도, 조인해서 레코드 건수가 늘어나기 전 정렬을 하는게 효율적인게 아닌가.

### Q) 스트리밍, 버퍼링 방식이 실제로 표기가 되지 않는지
- 지금 안씀.. 

### Q) 스트리밍 방식이 LIMIT 걸었을 시 성능이 개선되는 이유는, 1 다음에 풀스캔으로 2를 검색하고, 풀스캔을 3을 검색하는 방식으로 LIMIT이 걸린 것 까지 풀스캔 검색을 하기 때문인 건지.


### Q) 임시테이블에서 유니크 인덱스가 있는 임시테이블이 그렇지 않은 테이블보다 처리 성능이 느리다 했는데, 인덱스가 있는 테이블은 메모리가 커도 성능이 좋은 것이 아닌지. 임시테이블이라 다른 것인지.


### Q) 조인 버퍼를 사용하는 조인이 잘 이해가 안됨. 조인에 필요한 컬럼만 따로 조인 버퍼에 저장한 뒤, 그 테이블을 드리븐 테이블과 조인하는 건지

### Q) 만약 조인 버퍼에 저장될 드라이빙 테이블이 조인 버퍼보다 크면 어떻게 되는지

