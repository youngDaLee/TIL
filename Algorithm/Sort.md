# 정렬(Sorting)
1. 정렬
2. $O(n^2)$ 정렬
3. $O(n\log n)$ 정렬
4. 기타 정렬
5. 정리
## 1. 정렬
정렬(sorting)은 말 그대로 오름차순(ascending order) 혹은 내림차순(descending order)으로 나열하는 것.
- 자료 탐색에 있어 필수적!
  - ex) 리스트 연산(리스트에 원소를 추가/제거/검색)을 할 때 정렬되지 않은 리스트보다 정렬된 리스트의 성능이 더 좋음.

정렬 알고리즘은 성능에 따라 크게 **두 가지**로 나뉘어진다.
1. O(n^2)정렬 알고리즘
   - 버블정렬(bubble sort), 삽입정렬(insertion sort), 선택정렬(selection sort), ...
2. O(nlogn)정렬 알고리즘
   - 합병정렬(merge sort), 쾌속정렬(quick sort), 힙정렬(Heap sort), ...
## 2. O(n^2) 정렬
정렬 알고리즘의 성능이 정렬하고자 하는 원소의 수(n)의 제곱(n^2)에 비례함.
- 이동에 기반한 정렬 : 삽입정렬(insertion sort)
- 교환에 기반한 정렬 : 버블정렬(bubble sort), 선택정렬(selection sort)
### 2.1. 삽입 정렬(insertion sort)
손 안의 카드를 정렬하는 방법과 유사함.
- 추가(insert) 연산에 기반한 알고리즘
- 정렬되지 않은 리스트의 원소들을 차례로 정렬된 리스트에 추가하여 정렬 수행.
- 원소를 이동시켜 정렬 수행.

#### 기본 개념
- 배열의 가장 앞자리로부터 정렬된 부분 배열을 생성하고, 그 크기를 증가시킴
  - 부분 배열은 처음에는 배열의 첫 원소로 시작.
  - 마지막 부분 배열이 배열과 일치하면 정렬 완료
- 새로운 원소를 정렬된 부분 배열의 적단한 위치에 삽입해서 부분 배열의 정렬을 유지
- 정렬된 배열에 새로운 원소를 삽입하는 연산 필요
- 삽입 후에도 배열의 정렬 유지되어야 함.
#### 알고리즘 설계
- 배열의 원소를 하나씩 부분 배열에 삽입하며 정렬 수행
- 정렬 끝난 배열 앞부분을 부분 배열로 이동
  -  k번째 원소까지 정렬 끝난 상황 -> a[0] ~ a[k-1]을 부분 배열로 이동
- 부분 배열a[0 ... k-1]에 대해 (k+1)번째 원소인 a[k]를 a[0 ... k-1]에 삽입.
  - 부분 배열은 a[0 ... k-1] 에서 a[0 ... k]로 증가
#### 알고리즘 구현
c++
```
void insert(int x, int n, int b[]){
    int i, j;
    for(i = 0; i<n ; i++){
        if(b[i]>=x){
            for()
        }
    }
}
```
### 2.2. 버블 정렬(bubble sort)

### 2.3. 선택 정렬(selection sort)
가장 이해하기 쉬운 정렬 방법.
- 추가(insert) 연산에 기반한 정렬 알고리즘
- 리스트에서 크기 순으로 원소를 선택하여, 
## 3. O(n log n) 정렬
### 3.1. 분할 정복 방식

### 3.2. 합병 정렬(merge sort)

### 3.3. 쾌속 정렬(quick sort)

## 4. 기타 정렬

### 4.1. 쉘 정렬(shell sort)

### 4.2. 기수 정렬(radix sort)

## 5. 정리